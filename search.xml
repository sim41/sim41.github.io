<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ssh-protocol]]></title>
    <url>%2F2019%2F06%2F18%2Fssh-protocol%2F</url>
    <content type="text"><![CDATA[SSH协议这是一篇去年学习ssh协议时写的文，基本上是SSH标准协议的翻译，放上来仅供参考，里边的一些细节我也有些忘记了。 概述SSH是Secure SHell的缩写，即安全外壳协议，是一种在不安全网络提供安全远程登陆以及其他安全网络服务的协议。SSH是建立在应用层基础上的安全协议，可以有效防止远程管理过程中的信息泄露问题。 功能主要功能提供网络服务程序功能，加密传输数据，可抵抗中间人攻击。 应用场景 替代Telnet进行远程通信 提供安全FTP服务 为POP、PPP协议提供安全信道 组成SSH协议由三个子协议组成：传输层协议(SSH-TRANS)、用户认证协议(SSH-USERAUTH)、连接协议(SSH-CONNECT) SSH-TRANS功能安全的低级传输协议。提供服务器认证，保密性和完整性，还提供压缩功能。 通常运行在TCP/IP连接上，也可用于其他可靠数据流上。 身份验证是居于主机的，不执行用户认证，更高层的用户认证协议可以基于此协议设计。 规范端口通过TCP/IP使用时，端口默认为22 协议版本交换标识字符串： SSH-protoversion-softwareversion SP comments CR LF‘protoversion’是”2.0”（现多为SSH2版本），’comments’字符串可选，若包含’comments’字符串,SP字符(空格符,ASCII 32)务必将’softwareversion’和’comments’字符串分开。标识字符串必须由单个CR字符(回车符，ASCII 13)和单个LF字符（换行符，ASCII 10）终止。 字符串中不能出现其他的空字符，最大长度为255个字符(包含回车和换行)，在回车和换行(CR LF)之前的标识字符串部分用于Diffie-Hellman密钥交换。 实例： SSH-2.0-OpenSSH CR LF兼容性服务端为新版本，客户端为旧版本时，服务端可兼容旧版协议 服务端为旧版本，客户端为新版本时，服务端无法识别，须使用旧版本访问 数据包格式uint32 packet_length byte padding_length byte[n1] payload; n1 = packet_length - padding_length - 1 byte[n2] random padding; n2 = padding_length byte[m] mac (Message Authentication Code - MAC); m = mac_lengthpacket_length 数据包的长度(以字节为单位)，不包括’mac’或’packet_length’字段本身。 padding_length 随机填充字节的长度 payload 有效载荷：数据包的游泳内容。默认压缩为无，已协商压缩，此字段将被压缩 random padding 随机填充：任意长度的填充，使得总长度是密码块大小或8的倍数，取其较大者。必须至少由四个字节的填充，最大填充量是255个字节 mac 消息认证码，默认为无，若一些上，此字段包含MAC字节 压缩可选压缩，已协商压缩，则使用协商算法压缩“有效载荷”。 压缩方法：zlib可选ZLIB(LZ77)压缩 加密加密算法和密钥将在密钥交换期间进行协商。当加密生效时，每个数据包的数据包长度，填充长度，有效载荷和填充字段必须用给定算法加密。 数据完整性数据完整性通过在每个数据包中包含从共享密钥，数据包序列号和数据包内容计算出的MAC来加以保护。 消息认证算法和密钥在密钥交换期间进行协商，根据协商算法，计算方式为： mac = MAC（key，sequence_number || unencrypted_packet）unencrypted_packet是没有’mac’的整个分组 sequence_number是一个隐含的包序列号，表示为unit32格式 密钥交换采用Diffie-Hellman方法。密钥交换（kex）始于每边发送支持算法的名称列表 产生两个制：一个共享密钥K和一个交换散列H。加密和认证密钥来自于这两个值 流程 客户端和服务器端想对方发送SSH版本识别字符串 收到版本字符串后，双方通过质地的那个格式二进制包进行通信 在传输完版本字符串后，客户端和服务端开始进行密钥交换(key exchange，简称kex)。Kex用来让客户端和服务器生成本次通信的密钥和序列号。在kex的最后一步，服务器给客户端发送他的公钥，客户端查询本地的known_hosts查找志告公钥验证服务器身份。在kex之后，客户端进行SSH-AUTH，请求服务器验证自己的身份。 SSH-AUTH功能SSH认证协议提供了客户端认证功能，向服务器发起请求，验证客户端的合法性。 认证方法 password 密码验证 public key 无密码公钥验证 hostbased 基于主机的身份验证 规范身份验证请求消息格式： byte SSH_MSG_USERAUTH_REQUEST string user name(UTF-8) string service name(ASCII) string method name(ASCII) .... method specific fields如果用户名和服务名称发生改变，则断开连接 定义的方法名(method name)： &quot;publickey&quot; REQUIRED &quot;password&quot; OPTIONAL &quot;hostbased&quot; OPTIONAL &quot;none&quot; NOT RECOMMENDED认证协议消息号码一般的认证信息代码： SSH_MSG_USERAUTH_REQUEST 50 SSH_MSG_USERAUTH_FAILURE 51 SSH_MSG_USERAUTH_SUCCESS 52 SSH_MSG_USERAUTH_BANNER 53此外还有一些为方法特定的消息保留的消息编号(60到79) 认证方法1.公钥认证方法：publickey a. 客户端创建自己的密钥对，将公钥提交到需要访问的服务器上。 b. 客户端向服务器发起请求，请求用私钥签名进行认证。请求报文： byte SSH_MSG_USERAUTH_REQUEST string user name string service name string &quot;publickey&quot; boolean TRUE string public key algorithm name string public key to be used for authentication string signature其中签名项的内容为： string session identifier byte SSH_MSG_USERAUTH_REQUEST string user name string service name string &quot;publickey&quot; boolean TRUE string public key algorithm name string public key to be used for authenticationc. 服务器收到请求后，在公钥目录中查找对应用户，如果存在，则产生一个随机字符串，用公钥加密后发送给用户。 d. 用户收到字符串后，用自己的私钥进行解密，将解密后的字符串发送给服务器。 e. 服务器接收到字符串后与之前生成的随机字符串进行对比，如果一致，则允许用户登陆。 2.密码验证方法：password 客户端向服务器发起请求，发送包含自己用户名和对应密码的数据包，格式为： byte SSH_MSG_USERAUTH_REQUEST string user name string service name string &quot;password&quot; boolean FALSE string plaintext password(UTF-8)数据包由传输层进行加密 3.基于主机的身份验证:hostbased 通过来源主机和用户名进行身份验证，客户端发送消息请求身份认证，格式为： byte SSH_MSG_USERAUTH_REQUEST string user name string service name string &quot;hostbased&quot; string public key algorithm for host key string public host key and certificates for client host string client host name expressed as the FQDN(ASCII) string user name on the client host(UTF-8) string signature签名的值为： string session identifier byte SSH_MSG_USERAUTH_REQUEST string user name string service name string &quot;hostbased&quot; string public key algorithm for host key string public host key and certificates for client host string client host name expressed as the FQDN(ASCII) string user name on the client host(UTF-8)SSH-CONN功能提供交互式登陆会话，远程执行命令，转发TCP/IP连接和转发X11连接。 channel机制所有终端会话，转发连接等都是通过建立channel来通信的。任何一方都可以打开一个信道。多个信道被复用成一个单一的连接。 信道由末尾的数字进行标识。 信道是流量控制的。只有标为可用的窗口空间才可以发送数据。 打开信道任何一端都可以开启一个新的信道，并分配一个本地信道号。发送请求,包含本地信道号和初始窗口大小。请求格式： byte SSH_MSG_CHANNEL_OPEN string channel type(ASCII) uint32 sender channel uint32 initial window size uint32 maximum packet size .... channel type specific data follows远端回复是否可以打开信道： 打开信道 SSH_MSG_CHANNEL_OPEN_CONFIRMATION： byte SSH_MSG_CHANNEL_OPEN_CONFIRMATION uint32 recipient channel uint32 sender channel uint32 initial window size uint32 maximum packet size .... channel type specific data follows打开失败 SSH_MSG_CHANNEL_OPEN_FAILURE： byte SSH_MSG_CHANNEL_OPEN_FAILURE uint32 recipient channel uint32 reason code string description(UTF-8) string language tag原因代码(reason code)显示打开失败的原因 数据传输在打开新的信道时窗口大小已经规定，可以通过以下消息进行调整： byte SSH_MSG_CHANNEL_WINDOW_ADJUST uint32 recipient channel uint32 bytes to add窗口大小指定对方可以发送多少个字节。 数据传输的消息格式： byte SSH_MSG_CHANNEL_DATA uint32 recipient channel string data关闭信道当一方不再发送更多数据到一个信道时，应该发送SSH_MSG_CHANNEL_EOF，格式为： byte SSH_MSG_CHANNEL_EOF uint32 recipient channel当任何一方希望终止信道时，发送SSH_MSG_CHANNEL_CLOSE。收到此消息后，另一方必须回复一个SSH_MSG_CHANNEL_CLOSE。则该信道被视为已关闭。 特定信道请求许多信道类型值具有特定信道类型的扩展名。特定信道的请求格式为： byte SSH_MSG_CHANNEL_REQUEST uint32 recipient channel string request type(ASCII) boolean want reply .... type-specific data follows交互会话会话是程序的远程执行，该程序可以是shell，应用程序，系统命令或者某些内置子系统。会涉及到虚拟终端，X11转发。可以同时激活多个会话。 开始会话通过发送以下消息开始会话： byte SSH_MSG_CHANNEL_OPEN string &quot;session&quot; uint32 sender channel uint32 initial window size uint32 maximum packet size请求一个伪终端通过发送以下消息请求一个伪终端： byte SSH_MSG_CHANNEL_REQUEST uint32 recipient channel string &quot;pty-req&quot; boolean want_reply string TERM environment variable value uint32 terminal width, characters uint32 terminal height, rows uint32 terminal width, pixels uint32 terminal height, pixels string encoded terminal modesX11转发请求X11转发通过发送SSH_MSG_CHANNEL_REQUEST消息请求X11转发： byte SSH_MSG_CHANNEL_REQUEST uint32 recipient channel string &quot;x11-req&quot; boolean want reply boolean single connection string x11 authentication protocol string x11 authentication cookie uint32 x11 screen numberX11信道X11信道以信道开启请求的形式开启，请求通过的结果是开启一个独立于会话的信道，关闭会话信道不会关闭X11转发信道。请求格式为: byte SSH_MSG_CHANNEL_OPEN string &quot;x11&quot; uint32 sender channel uint32 initial window size uint32 maximum packet size string originator address uint32 originator port接受到请求的一方应使用SSH_MSG_CHANNEL_OPEN_CONFIRMATION开启信道或者SSH_MSG_CHANNEL_OPEN_FAILURE开启信道失败进行响应。 环境变量传递环境变量可以传递给shell/command。请求格式为： byte SSH_MSG_CHANNEL_REQUEST uint32 recipient channel string &quot;env&quot; boolean want reply string variable name string variable value启动shell/command会话建立时，远程终端的一个程序开启。这个程序可以是shell，应用程序，或者独立于主机的子系统。 byte SSH_MSG_CHANNEL_REQUEST uint32 recipient channel string &quot;shell&quot; boolean want reply该消息请求开启一个用户默认的shell byte SSH_MSG_CHANNEL_REQUEST uint32 recipient channel string &quot;exec&quot; boolean want reply string command该消息请求服务器执行给定的命令。’command’字符串可能包含一个路径。 byte SSH_MSG_CHANNEL_REQUEST uint32 recipient channel string &quot;subsystem&quot; boolean want reply string subsystem name该消息请求开启一个预定义的子系统。 会话数据传输会话的数据传输使用SSH_MSG_CHANNEL\DATA和SSH_MSG_CHANNEL_EXTENDED_DATA包和窗口机制。SSH_MSG_CHANNEL_EXTENDED_DATA已被定义为stderr数据。 其他控制消息 窗口尺寸更改消息 本地流量控制 信号 返回退出状态在另一端的命令终止时，会返回命令的退出状态。收到消息后，通过SSH_MSG_CHANNEL_CLOSE关闭信道。消息格式如下: byte SSH_MSG_CHANNEL_REQUEST uint32 recipient channel string &quot;exit-signal&quot; boolean FALSE string signal name (without the &quot;SIG&quot; prefix) boolean core dumped string error message(UTF-8) string language tagTCP/IP端口转发请求端口转发请求消息格式： byte SSH_MSG_GLOBAL_REQUEST string &quot;tcpip-forward&quot; boolean want reply string address to bind uint32 port number to bindTCP/IP转发信道当连接达到远程转发的端口被请求时，打开一个信道将端口转发给另一个端口侧。请求消息格式： byte SSH_MSG_CHANNEL_OPEN string &quot;forwarded-tcpip&quot; uint32 sender channel uint32 initial window size uint32 maximum packet size string address that was connected uint32 port that was connected string originator IP address uint32 originator port工作过程 版本号协商阶段，通信双方确定使用的协议版本 密钥和算法协商阶段，通信双方协商出最终使用的算法 认证阶段，SSH客户端向服务器端发起认证请求，服务器端对客户端进行认证 会话请求阶段，认证通过后，客户端向服务器端发送会话请求 交互会话阶段，会话请求通过后，服务器端和客户端进行交互会话]]></content>
      <categories>
        <category>协议</category>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tls]]></title>
    <url>%2F2019%2F06%2F18%2Ftls%2F</url>
    <content type="text"><![CDATA[SSL/TLS协议一、 概述关于SSL/TLS的历史和作用此处按下不表，可以检索相关文章进行了解。在建目录的时候，我还认证考虑了一下应该将SSL/TLS归类到几层协议中，经过思考和查找资料，我决定放弃，SSL/TLS协议基本上可以分为握手协议，和传输协议两部分，介于TCP和HTTP协议之间，可能并不太适用于与OSI模型进行匹配。]]></content>
      <categories>
        <category>协议</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-charset]]></title>
    <url>%2F2019%2F06%2F17%2Fmysql-charset%2F</url>
    <content type="text"><![CDATA[数据库系列 1—MySQL数据库协议之字符集与排序开篇碎碎念​ 因为日常工作与数据库打交道，先准备写点简单的自己关于数据库的认识。今天刚好在看有关字符集协商的问题，简单的开篇讲一下MySQL中的字符集设定。 ​ MySQL数据库的设置与其协议都是简洁且自由度高的，这两种特性综合起来就导致了在使用MySQL数据库中会遇到一些由于灵活的配置导致的坑。 ​ 可能很多人都遇到过一个问题，就是在使用MySQL数据库时，会发先一些中文字符或者表情产生了乱码。或者使用了较新的客户端去连接服务器的时候，产生了类似于「ERROR 1115 (42000): Unknown character set: ‘utf8mb4’」这样连接失败的错误。 MySQL中的字符集character sets​ MySQL中的字符集由两部分构成，一是字符的编码方式(character sets)，二是编码的排序方式(collation)。看字面意思，编码方式就是单个字符的编码，排序方式就是比较字符之间顺序的规则。网上搜索相关的内容大多重复讲了这一点。 ​ 要搞清楚字符集，首先要弄明白字符集在什么时候需要。字符集是我们可见的字符在计算机中存储的一种方式，每个字符根据规则按照一定长度存储为十六进制（二进制）的值，而这个值如何解释则决定了它在打印时产生的字符。 ​ 首先要明确一个分类，字符集在数据库中有两大类的使用（我个人的理解，如有纰漏请指正）。我感觉网上现有的解释都混淆了这两类使用，导致不容易理解。 - 存储使用 - 传输使用​ 存储使用，就是在数据库服务端，对数据进行存储时使用的编码格式。在MySQL数据库中的表现为server, database, table, column四个层次的字符集设置，可以很详细地设定字符集。这个一般是在设计数据库时定义的，和我们要存储的数据的类型有关，通常也要同时确认其排序规则，关于排序规则后问再讲。 ​ 传输使用，发生在客户端（官方客户端或者我们自己的程序或者代理软件等等）和数据库服务器进行交互时。客户端和服务器交互，必然要进行通信，不论上层的封装是基于tcp/ip，还是pipe转发，本地套接字，其应用层的数据库协议都是相同的。服务端从库中取出数据，按照存储的字符集设定解释，然后再按照某种编码方式传输给客户端，客户端按照这种编码方式解释数据流；反之亦然。 ​ 如果我们自己来设计，服务器、客户端、传输协议中的编码方式最好是统一的，这样能够用最少的解释和编码过程。MySQL数据库的做法是让客户端声明一种编码方式，然后服务器与客户端的通信都使用同一种编码方式。在MySQL协议的握手过程中，服务端先发送第一个包，客户端在返回包时声明了自己要用的字符集以及排序方式。（字符集对排序方式是一对多的关系，因此也可以理解为只需要传输特定的排序方式）这个排序方式以一个字节的十六进制值表示。服务端收到这个字符集/排序方式后，查看自己是否支持，如果支持，则采用该方式进行编码解码，进行通行。如果不支持，则产生回退过程，服务器将自己支持的字符集发送给客户端，进行协商，客户端选择一种进行支持，或者双方无法达成一致，断开连接。可以说，在通信过程中，字符集的选择主要取决于客户端的声明。这一个字符集最后的表现形式为三项设定：character_set_client, character_set_results和character_set_connection。可以使用以下语句进行查询。 1SHOW SESSION VARIABLES LIKE 'character\_set\_%'; 可以看到这三项的值是统一的。据我现在的调研，各种客户端基本都不支持设置默认字符集，不同的客户端版本自己会声明一种字符集，5.5之前多数为latin1，5.7以后基本上都是utf8mb4，所以坑多为5.5.-5.7之间，可能存在声明utf8的字符集。一些比较奇怪的声明是客户端将这一标志位声明为0xff即255，但并没有对应的字符集，我猜测这可能是声称自己自持现有的所有字符集。 ​ 客户端的配置项不提供指定字符集的方式，我们可以直接修改服务器中的三项设定 SET character_set_client = charset_name; SET character_set_results = charset_name; SET character_set_connection = charset_name;一般来说使用匹配版本的客户端和服务器，能够避免大量问题，如果要自己指定通信时的字符集，推荐5.1之前都使用latin1（5.5之前不止此utf8mb4编码），5.5以后都可以使用utf8mb4编码。注意：ucs2，utf16，utf32是不被支持的。 ​ 而关于之前容易产生的两种错误，第一个乱码的情况，一般是因为字符集不统一导致解码错误。在MySQL中，多数表现为按照utf8格式进行编码时产生的。因为历史遗留问题，MySQL中的一个坑是其utf8编码并不是我们通常认知中的utf8编码，这是一种最大长度为3字节的编码，因此当字符的长度是4字节时，解析就会出现错误，导致乱码的出现。MySQL官方也终于在MySQL5.5版本开始支持了4字节uft8，即utf8mb4字符集。第二个错误是使用了较高的（默认版本为5.7+）客户端连接较老的服务器（5.1），导致后续客户端申请更换字符集时遭到了拒绝。 1SET NAMES 'utf8mb4'; collations​ 排序方式是比较单个字符顺序的规则定义，比如忽视大小写，则A与a的排序是等同的；而b则应该排在a之后。每个字符编码方式都对应一种默认的排序方式。 尾记​ 第一次写文章，思路不够清晰，可能存在问题的地方也比较多，希望接下来能够清晰地做一个数据库专题，尤其是关于数据库协议相关的内容。 引用 https://dev.mysql.com/doc/refman/5.5/en/charset-connection.html]]></content>
      <categories>
        <category>database</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开篇]]></title>
    <url>%2F2019%2F06%2F13%2Findex%2F</url>
    <content type="text"><![CDATA[经过使用Jekyll搭建，再转向hexo，用next主题建起了博客；期间也入了OS X的坑。填了一些坑，走了一些歪路，总算是建起来了，也算是步入正轨。 博客中主要写一些技术分享的文章，看心情可能也会有日常记录。主要关注数据库技术，网络相关技术，各种协议以及关于服务器部署的相关技术。环境主要基于Linux/OS X，语言主要是C/go（未来希望能够熟悉C++，其他语言视需求扩展）。]]></content>
  </entry>
</search>
