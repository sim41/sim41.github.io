<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[sql]]></title>
    <url>%2F2019%2F09%2F05%2Fsql%2F</url>
    <content type="text"><![CDATA[有关SQL语句的一些思考日常关于SQL语句的一些想法，一点自己的见解，今天分享出来记录并提供更正和补全。主要是关于SQL语句的分类和原理的拙见。 SQL语句分类一般来说，SQL语句根据用途分为 数据操作语言(DML：Data Manipulation Language) 由数据库管理系统(DBMS) 提供，用于让用户或程序员使用，实现对数据库中数据的操作。 主要包含 SELECT、 INSERT、 UPDATE、 DELETE、 MERGE、 CALL、 EXPLAIN PLAN、 LOCK TABLE等语句。 数据定义语言(DDL：Data Definition Language) 用于定义SQL模式、基本表、视图和索引的创建和撤消操作。 主要包含 CREATE、 ALTER、 DROP、 TRUNCATE、 COMMENT、 REPLACE(RENAME)等语句，一般不需要commit等事务操作。 数据控制语言(DCL：Data Control Language) 用于数据库授权、角色控制等管理工作。 主要包含 GRANT、 REVOKE等语句。 事务控制语言(TCL：Transaction Control Language) 用于数据库的事务管理。 主要包含 SAVEPOINT、 ROLLBACK、 COMMIT、 SET TRANSACTION等语句。 这种分类方式是oracle给出的，网上可以查询到的也大多认可了此分类方式。不过今天谈的不是这种分类，以上仅作为参考。 另一种分类也算不上是分类吧，我个人的一点看法。因为我工作的性质，我更关注数据库协议相关的内容。按照数据库查询语句的生命周期和用途，也大致可以分为四种类型。 第一种是最简洁常用的操作/查询语句，其实与DML的定义差不多，在MySQL中就是query，ASE中叫language等等。这种语句的生命周期就是一次查询，一次完整请求对应一次完整响应，基本上不需要进行维护操作。 第二种是在基础查询语句上提供参数化的功能，可能叫参数化/模版/动态查询等等。这种语句也可以看作一种函数，将查询语句中的一些参数作为变量，有的支持变量命名，有的数据库只支持匿名参数。改语句的生命周期有一次查询语句的，此时多数由客户端进行维护，复用模版时自行进行参数化查询，然后附加参数的值。也有的生命周期存在于创建和释放模版之间，可以认为是在服务器注册了一个临时的函数。针对一次查询可以认为将参数替换后，也是一次交互，一次请求对一次响应。 第三种就是RPC。可以认为是函数，执行了一系列的查询操作。服务器一般都内置了很多的RPC，生命周期可以视为永久，不过针对结果来讲，还是一次请求对一次完整响应。自定义的RPC生命周期维护在创建和释放之间。 第四种就是游标。游标是针对查询结果的，生命周期一般是伴随着创建游标产生，附加在一条查询语句上，随着删除游标请求而释放。之所以需要游标，是很多查询是长期且返回很大的结果集的，我们不太可能一次性获取所有结果，游标可以让我们随着需要去取自己想要的数据。大部分游标不仅绑定在查询语句上，而且是与连接相关的，一旦连接断开，服务器会自动释放游标。不过也有些游标是由服务器维护，直到客户端请求释放才会结束游标的。 综上，第一种类型可以认为客户端不需要维护任何的生命周期，可以迅速的拿到请求与响应。第二种主要需要维护一条查询语句和一个参数列表。第三种一般需要维护一个RPC名称/查询语句和可能的参数列表。而第四种需要维护的就比较多了，要维护游标id，查询语句，参数，以及需要用到的结果集。 其实好像这篇比较水，主要是想到一些就记下来了。]]></content>
      <categories>
        <category>database</category>
        <category>concept</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[caculator]]></title>
    <url>%2F2019%2F09%2F03%2Fcaculator%2F</url>
    <content type="text"><![CDATA[10% + 10% 他为什么等于0.11好久没有更新了，最近比较忙。昨天微博上突然「曝光」(现在这个词都只有读bào光了，高考的时候还是pù光，歪题了)出好多安卓手机的简单计算器在计算10%+10%时居然给出了结果是0.11，不是人们预想的0.2=20%。 现象先描述现象，简单计算器中，计算某项加或减百分数。xx + n% / xx - n% 12BNF表示：PERCENT ::= &#123;expr&#125; &lt;+|-&gt; (&lt;num&gt;"%") 此时计算器会将算式解释为 xx 为某个计算结果，+/-n%代表着对当前计算结果进行+/-n%倍的计算。例如昨天产生的争议10% + 10%，被解释为10% + 10% * 10%。事实上前边的表达式为纯数字/计算结果时，也会有同样的现象。例如6 + 10%，计算结果为6 + 6 *10% = 6.6。这种现象其实在Windows计算器的标准模式下也会出现，还有一干的安卓计算器的简单模式。 结论再说结论，先把结论放上来，有兴趣的可以继续看，不想继续了解的看完结论就明白了。首先，结论是，这不是bug，这是产品特性。因为在这些计算器里就是这样定义百分数计算的。这些计算器将+/-百分数的计算解释为对之前的结果进行加/减比例的计算。 之所以这样做，是因为在设计计算器的算法时，出于一个前提，即人们很少计算百分数的直接加减法，更常见的是诸如在计算税收，利息等等问题时，会对某个结果进行（1 + n%）的计算。比如存款10000元，年利息5%，一年后的存款为10000 + 5%，得到10500。计算器一般都是边解释边进行计算的，所以实时都会出现一个当前结果。也可能早起的计算器屏幕有限，输入方法不够友好，所以不方便输入1 * （1 + 10%）这种结合，所以有这种设计。 而针对乘法/除法，用户的需求就是直接对某个数计算百分比倍数，所以和我们通常认知的结果是一致的。 所以这种现象只是产品设计，不是bug，windows和安卓都存在。安卓软件可能用了相同的开源组件/库或者内置计算器等，而部分手机没有采用这种解决方案。至于看到一些乱分析说自己是学计算机的，这种明显就是浮点数的问题blabla的，笑一笑就ok了。结论很简单，是审计问题，不是bug，是「产品经理」的锅hhh。 分析我最开始也以为是语义分析一类做错了导致的bug，后来一想，计算器一般都采用的是逆波兰式进行分析计算的，应该不存在二义性，而且简单计算器都是一边计算一边出结果的，显然不会有这样的bug。后来发现微软在Windows中的计算器也是这样设计的，那应该是某种设计问题。刚好微软的计算器开源了，那我们找一下他们是怎样实现的。 Windows计算器中的标准模式中对于百分数计算的定义： 1234567891011121314case IDC_PERCENT: &#123; // If the operator is multiply/divide, we evaluate this as "X [op] (Y%)" // Otherwise, we evaluate it as "X [op] (X * Y%)" if (m_nOpCode == IDC_MUL || m_nOpCode == IDC_DIV) &#123; result = rat / 100; &#125; else &#123; result = rat * (m_lastVal / 100); &#125; break; &#125; 这样逻辑就十分清晰了，注释中也解释了会将加减百分数计算解释为result = pre-result * persent / 100（1 + 10%解释为 1 + 1 * 10 / 100) 至于逆波兰式，有兴趣的话我可以再写一篇解释一下解释过程和计算过程。 参考： Microsoft github caculator https://github.com/microsoft/calculator/blob/2826d370565092dfca9a983a5fc6ec0b8b1c62e1/src/CalcManager/CEngine/scifunc.cpp row 79]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理,语义分析</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F23%2Fmysql-parser%2F</url>
    <content type="text"><![CDATA[mysql parser 12345678910%type &lt;lexer.charset&gt; opt_collate charset_name old_or_new_charset_name old_or_new_charset_name_or_default collation_name opt_load_data_charset UNDERSCORE_CHARSET ascii unicode default_charset default_collation 123456789create: CREATE DATABASE opt_if_not_exists ident &#123; Lex-&gt;create_info= YYTHD-&gt;alloc_typed&lt;HA_CREATE_INFO&gt;(); if (Lex-&gt;create_info == NULL) MYSQL_YYABORT; // OOM Lex-&gt;create_info-&gt;default_table_charset= NULL; Lex-&gt;create_info-&gt;used_fields= 0; &#125; 123456789101112131415161718192021222324create_database_option: default_collation &#123; if (set_default_collation(Lex-&gt;create_info, $Extra close brace or missing open brace1)) MYSQL_YYABORT; &#125; | default_charset &#123; if (set_default_charset(Lex-&gt;create_info, $1)) MYSQL_YYABORT; &#125; | default_encryption &#123; // Validate if we have either 'y|Y' or 'n|N' if (my_strcasecmp(system_charset_info, $Misplaced &amp;1.str, "Y") != 0 &amp;&amp; my_strcasecmp(system_charset_info, $1.str, "N") != 0) &#123; my_error(ER_WRONG_VALUE, MYF(0), "argument (should be Y or N)", $1.str); MYSQL_YYABORT; &#125;​ Lex-&gt;create_info-&gt;encrypt_type= $1;​ Lex-&gt;create_info-&gt;used_fields |= HA_CREATE_USED_DEFAULT_ENCRYPTION;​ &#125;​ ; ​ ​ 123456789create_table_option: | default_charset &#123; $$= NEW_PTN PT_create_table_default_charset($1); &#125; | default_collation &#123; $$= NEW_PTN PT_create_table_default_collation($1); &#125; 1234567891011default_charset: opt_default character_set opt_equal charset_name &#123; $$ = $4; &#125; ;default_collation: opt_default COLLATE_SYM opt_equal collation_name &#123; $$ = $4;&#125; ;default_encryption: opt_default ENCRYPTION_SYM opt_equal TEXT_STRING_sys &#123; $$ = $4;&#125; ;]]></content>
  </entry>
  <entry>
    <title><![CDATA[openssh]]></title>
    <url>%2F2019%2F06%2F20%2Fopenssh%2F</url>
    <content type="text"><![CDATA[openssh最近由于到期末，一致在忙着交结课作业，还要临时抱佛脚准备期末考试，日常熬夜到2，3点。没什么时间更新，继续旧文新更。还是一篇去年的关于ssh的文章，有关openssh的使用说明。ssh篇至此完结。 安装安装openssh客户端 默认安装了openssh客户端 软件包安装:apt,yum,rpm 源码编译安装,下载源码(下载支持库) 安装openssh服务器openssh-server 配置服务器配置sshd_config 常用配置基本配置 Port 22: 监听的端口 ListenAddress 0.0.0.0: 监听的地址,0.0.0.0代表监听本地的所有已经启用的IP Portocol 2: ssh协议版本号 LogLevel INFO: 日志级别(INFO级别) 认证相关 Allow user,…: 允许登陆的用户 Allow group,…: 允许登陆的用户组 Deny user,…: 禁止登陆的用户 Deny group,…: 禁止登陆的用户组 LoginGraceTime 20s: 登陆超时 PermitRootLogin no: 允许root登陆 MaxAuthTries 6: 输入密码允许次数,达到次数后一段时间不可登陆 MaxSessions 10: 最大同时打开会话数 RSAAuthentication yes: 是否启用RSA认证 PubkeyAuthentication yes: 是否启用公钥认证 PasswordAuthentication no: 是否启用密码认证 PermitEmptyPasswords no: 是否允许空密码登陆 ClientAliveInterval 300: 会话超时时间 ClientAliveCountMax 3: 会话超时次数判断 用户手册名称 sshd_config: OpenSSH SSH守护进程配置文件 描述 sshd从/etc/ssh/sshd_config(或在命令行中用-f指定配置文件)读取配置数据.该文件包含每行一个关键字-参数对.对于每个关键字,使用第一个获得的值.’#’和空行开始的行解释为注释.包含空格的参数可以使用双引号(“”)包含在内 关键字不区分大小写,参数区分大小写 关键字列表 时间格式 sshd命令行参数和配置文件选项中指定时间的参数,可以用time[qualifier]的格式表示,qualifier代表时间单位,由以下值: - &lt;none&gt; seconds 单位为空时默认为s - s|S seconds - m|M minutes - h|H hours - d|D days - w|W weeksTOKENS(标记) 某些关键字的参数可以使用标记符进行传递 %% 字义的&apos;%&apos;本身 %D 接收到的传入连接的路由域 %F CA密钥的指纹 %f 证书木有的指纹 %h 用户的home目录地址 %i 证书的密钥ID %K base64编码的CA密钥 %k base64编码的认证密钥/证书 %s 证书序列号 %T CA密钥的类型 %t 证书密钥的类型 %u 用户名AuthorizedKeysCommand 接受 %%, %f, %h, %k, %t, 和 %u. AuthorizedKeysFile 接受 %%, %h, 和 %u. AuthorizedPrincipalsCommand 接受 %%, %F, %f, %h, %i, %K, %k, %s, %T, %t, 和 %u. AuthorizedPrincipalsFile 接受 %%, %h, 和 %u. ChrootDiretory 接受%%, %h, 和 %u. RoutingDomain 接受%D.传入 文件 sshd的配置在/etc/ssh/sshd_config中,该文件只能由root用户写入,但建议是(非必须)全局可读的 服务器进程sshd OpenSSH SSH守护进程 命令1sshd [-46DdeiqTt] [-C connection_spec] [-c host_certificate_file] [-E log_file] [-f config_file] [-g login_grace_time] [-h host_key_file] [-o option] [-p port] [-u len] 参数解释sshd(OpenSSH Daemon)是ssh的守护进程.sshd监听来自客户端的连接,通常从/etc/rc中的启动项开始.该进程为每个传入分配一个新的守护进程 选项 -4 强制sshd仅使用IPv4地址 -6 强制sshd仅使用IPv6地址 -C connection_spec 指定用于-T扩展测试模式的连接参数.提供参数,配置文件中可能会应用的任何Match指令都将在配置写入标准输出之前应用.参数以key-value值对的形式提供.可以使用多个-C选项想或逗号分隔列表.关键字包括addr(元地址),user(用户),host(主机名),laddr(本地地址),lport(本地端口号)和rdomain(路由域) -c host_certificate_file 指定用于在密钥交互期间证明sshd的证书路径.证书文件必须与使用-h选项或HostKey配置指令指定的主机密钥文件匹配 -D 选定该模式,sshd不会分叉并不会成为守护进程.该模式可以简易监听sshd -d Debug模式.服务器不会进入后台模式,发送明确的debug输出到标准错误信息.服务器不会分支并只会处理一个连接.多重-d选项增加了调试级别,最高为3 -E log_file 将调试日志写入log_file而不是系统日志 -e 将调试日志写入标准错误而不是系统日志 -f config_file 指定配置文件的名称.缺省值是/etc/ssh/sshd_config.如果没有配置文件,sshd拒绝启动 -g login_grace_time 为客户端身份验证时间进行限制(默认120秒).如果客户端在限定时间内为能对用户进行身份验证,则服务器将断开连接并退出.值为0表示没有限制 -h host_key_file 指定读取主机密钥的文件.如果sshd不是以超级用户身份运行,则必须给出该选项(因为通常主机密钥文件不能被除root以外的任何人读取).缺省值是/etc/ssh/ssh_host_ecdsa_key, /etc/ssh/ssh_host_ed25519_key和/etc/ssh/ssh_host_rsa_key.对于不同的主机密钥算法可能有多个主机密钥文件 -i 指定从inetd运行sshd -o option 为可用于配置文件的格式提供选项.这对于指定没有单独的命令行标志的选项很有用.这些选项的配置值在sshd_config中 -p port 指定服务器监听连接的端口(缺省值为22).多个端口选项是允许的.当指定命令行端口时,配置文件中使用Port选项指定的设置将会被忽略.使用ListenAddress选项指定的端口会覆盖命令行端口 -q 静音模式.什么都不会发送到系统日志.通常记录每个连接的开始,认证和终止 -T 扩展测试模式.检查配置文件的有效性,将有效配置输出到标准输出流;或者通过使用一个或多个-C选项指定连接参数来应用匹配规则 -t 测试模式.只检查配置文件的有效性和密钥的完整性.对于可靠地更新sshd很有用,因为配置选项可能会更改 -u len 该选项用于指定存储远程主机名的utmp结构的字段大小.如果解析的主机名比len长,则会使用点分十进制.这允许具有很长主机名的主机溢出该字段后仍然被唯一标识.指定-u0 表示只应将点分十进制地址放入utmp文件中.-u0也可以用来防止sshd发出DNS请求,除非认证机制或配置需要.可能需要DNS身份验证机制包括HostbasedAuthentication并在密钥文件中使用from=”pattern-list”选项.需要DNS的配置选项包括在AllowUsers或DenyUsers中使用USER@HOST模式 验证 sshd只支持SSH2协议.每台主机都有一个主机专用密钥,用于识别主机.每当客户端连接时,守护进程都会使用其公共主机密钥进行响应.客户端将主机密钥与自己的数据库进行比较,验证其是否更改. 通过Diffie-Hellman密钥协议提供前向安全性.该密钥协议产生共享会话密钥.会话的其余部分使用堆成加密,当前使用128位AES, Blowfish, 3DES, CAST128, Arcfour, 192位AES或256位AES.客户端选择使用服务器提供的加密算法.此外,会话完整性通关过加密消息认证代码(hmac-md5, hmac-sha1, umac-64, umac-128, hmac-sha2-256或hmac-sha2-512)提供. 服务器和客户端进入认证对话框.客户端尝试使用基于主机的身份验证,公钥身份验证,键盘交互(质询-挑战)验证或密码身份验证方式进行身份验证. 如果客户端成功进行身份验证,则会输入用于准备会话的对话框.此时,客户端可能会请求分配伪终端,转发X11连接,转发TCP连接或通过安全通道转发身份验证代理连接等操作. 此后客户端请求一个shell或执行一个命令,双方进入会话模式.此模式下,任何一方都可以随时发送数据,并将这些数据转发到服务器端的shell或命令以及客户端的用户终端 当用户程序终止且所有转发的X11和其他连接关闭时,服务器向客户端发送命令退出状态,双方退出 登陆过程当一个用户成功登陆时,sshd将会执行: 如果登陆在tty上,且未指定任何命令,输出最后登陆时间和/etc/motd(除非文件中配置了保护选项) 如果登陆在tty上,记录登陆时间 检查/etc/nologin;如果存在,打印内容并退出(root以为) 更改以普通用户权限运行 建立级别的环境 如果文件存在,且允许用户更改其环境,读取文件~/.ssh/environment 更改用户的主目录 如果~/.ssh/rc存在并且设置了sshd_config中PermitUserRC选项,则运行它;否则,如果/etc/ssh/sshrc存在,运行它;否则运行xauth. 运行用户的shell或命令.所有的命令都在系统密码数据库中指定的用户登陆shell才可以运行 SSHRC如果~/.ssh/rc文件存在,sh将会在读取环境配置文件后,启动用户shell或命令前执行.它不能在stdout上产生任何输出,而必须使用stderr.如果正在使用X11转发,将会在标准输入中接收到proto cookie对(并展示在X11环境中).该脚本必须调用xauth,因为sshd不会自动运行xauth来添加X11 cookie 该文件的主要目的时在用户的主目录可访问之前运行可能协议的任何初始化例程. AUTHORIZED_KEYS文件格式AuthorizedKeysFile指定包含 用于公钥认证的公钥 的文件;如果未指定该项,则缺省值为~/.ssh/authorized_keys 和 ~/.ssh/authorized_keys2. 文件的每一行都包含一个关键字.公钥由以下空格分隔字段组成: options, keytype, base64-encoded key, comment. options选项字段时可选的,keytype密钥类型是:“ecdsa-sha2-nistp256”, “ecdsa-sha2-nistp384”, “ecdsa-sha2-nistp521”, “ssh-ed25519”, “ssh-dss” or “ssh-rsa”中的一种;commit注释字段不用于任何功能,方便识别 sshd强制执行1024位的最小RSA密钥模数大小 选项 选项由都会分隔的规范组成.除双引号外,不需要由空格 agent-forwarding 代理转发,启用由restrict选项禁用的身份验证代理转发 cert-authority 证书中心,指定列出的密钥是可信的验证机构 command=”command” 指定只要使用该密钥进行身份验证就执行该命令.用户提供的密钥将会被忽略 environment=”NAME=value” 指定在使用该密钥登陆时要将字符串添加到环境中,此方式设置的环境变量会覆盖其他默认环境值.允许多个选项 expiry-time=”timespec” 指定密钥不会被接受的时间 from=”pattern-list” 指定除了公钥认证意外,远程主机的规范名称或其IP地址必须存在于逗号分隔的模式列表中 no-agent-forwarding 无代理转发,使用该密钥时禁止身份验证代理转发 no-port-forwarding 无端口转发,使用该密钥时禁止TCP转发.客户端的任何端口转发都会返回错误 no-pty 防止tty分配 no-user-rc 禁用~/.ssh/rc的执行 no-X11-forwarding 禁用X11转发 primitopen=”host:port” 限制使用ssh -L进行本地端口转发,使其只能连接到指定的主机和端口.可以通过将地址放在方括号中指定IPv6地址.多个规则用逗号分隔. port-forwarding 启用由restrict选项禁用的端口转发 principals=”principals” 在cert-authority行上,以逗号分隔列表的形式指定允许的证书中心.至少一个证书机构协议存在于接受的可信机构中 pty 允许启用由restrict禁用的tty分配 restrict 启用所有限制,禁用端口,代理和X11转发,以及禁止PTY分配和执行~/.ssh/rc tunnel=”n” 在服务器上请求tun设备.如没有该选项,客户端请求隧道,将使用下一个可用设备 user-rc 启用由restrict选项禁用的~/.ssh/rc X11-forwarding 启用由restirct选项禁用的~/.ssh/rc SSH_KNOWN_HOSTS文件格式/etc/ssh/ssh_know_hosts/和~/.ssh/known_hosts文件中包含着已知主机的主机公钥.全局文件由管理员准备,并且每个用户文件都会自动维护:每当用户连接到未知主机时,其密钥都会添加到每个用户文件中 文件包含字段:markers(标记,可选项), hostnames(主机名), keytype(密钥类型), base64-encoded key(base64编码密钥), comment(注释). markers: 标记是可选的,但如果存在该字段,则必须是认证中心cert-authority中的一个(“@cert-authority”),表明该行包含CA密钥 或”@revorked”表示该密钥在该行被撤销,不能被接收 hostnames: 主机名是逗号分隔的模式列表(‘*’和’?’为通配符);每个模式依次与主机名匹配. 模式可以使用!来表示否定:如果主机名与否定模式相匹配,即使与另一模式相匹配,也不会被接收.主机名或地址可以可选地包含在’[‘ ‘]’中,然后以’:’加非标准端口表示 或者在公开的文件中,以散列形式存储主机名并隐藏主机名和地址 keytype base64-encoded key keytype 和 base64编码的密钥直接从主机密钥中获取,可以从/etc/ssh/ssh_host_rsa_key.pub获取.可选的注释会持续到该行结尾 客户端配置ssh_config 客户端配置文件 概要ssh以以下顺序获取配置信息: 命令行选项 用户的配置文件(~/.ssh/config) 系统的全局配置文件(/etc/ssh/ssh_config) 对于每个参数,将使用第一个获得的值,一般在文件开头附近提供主机特定声明,在结尾处提供默认值 使用key-value对表示参数,’#’和空行开始的行解释为注释 关键字关键字不区分大小写,参数区分大小写 host 限制之后的参数声明仅限于给定模式匹配的主机.给定多个模式,以空格机型分隔.’*’为通配符,当个使用为所有主机提供全局默认值 可以使用’!’作为否定模式,该主机模式将会被忽略 match 只有满足match关键字后边的条件,才可以使用以后的参数声明.可用的标准关键字是:canonical, exec, host, originalhost, user 和 localuser.match条件可用单独使用,组合使用或使用’all’关键字表示全部匹配.’all’关键字只可以单独使用或在canonical后立即出现.其他关键字可用任意组合.除了canonical和all关键字,其他的关键字都需要一个参数.可用通过’!’表示否定模式. canonical关键字只有当配置文件被主机名规范重新分析后才发生匹配.对指定只有规范主机名才可以工作很有效 exec关键字执行用户shell中指定的命令.exec接收TOKENS中定义的token作为参数 其他关键字必须是单个条目或是逗号分隔的列表,且可用使用PATTERNNS中定义的通配符和否定运算符.Hostname或CanonicalizeHostname选项中有任何替换内容,则host关键字和目标主机名进行匹配.originalhost关键字匹配命令行中指定的主机名.user关键字匹配远程主机上的目标用户名.localuser关键字匹配运行ssh的本地用户名 AddKeysToAgent 指定密钥是否应该自动添加到正在运行的ssh-agent.参数为:yes, confirm, ask 或 no.参数设置为yes,且从文件加载密钥,则密钥及其密码将添加到具有默认生命周期的代理程序.设为confirm,则每次使用密钥时都需要进行确认.设为ask,则在添加密钥之前,ssh将需要使用该SSH_ASKPASS程序进行确认.设为no,则不向文件添加密钥 AddressFamily 指定地址族,参数:any,inet,inet6 BatchMode 批处理模式,参数yes/no.设定为yes,则密码/密码查询将被禁用 BindAddress 使用本地机器上的指定地址作为连接的源地址(只用于具有多个地址的系统),如果UsePrivilegedPort设定为yes,则该项不生效. BindInterface 使用指定接口作为连接的源地址.同上 CanonicalDomains 启用CanonicalizeHostname时,此选项指定搜索目标主机的域后缀列表 CanonicalizeFallbackLocal 指定主机名规范化失败时是否失败并报错 CanonicalizeHostname 指定是否执行明确的主机名规范化.默认设为no,不执行任何名称重写,并让系统解析器处理所有主机名查找.如果设为yes,对不适用ProxyCommand的连接,尝试使用CanonicalDomains后缀和CanonicalizePermittedCNAMEs规则对于命令行中指定的主机名进行鬼画符.设为always,将会将规范化应用于代理连接 CanonicalizeMaxDots 指定在禁用规范化之前主机名中最大点数.默认为1 CanonicalizePermittedCNAMEs 指定规则用于在主机名进行规范化时是否应遵循CNAME. CertificateFile 指定读取用户证书的文件 ChallengeResponseAuthentication 指定是否使用挑战-应答模式验证 CheckHostIP 默认为yes,ssh将另外检查呢known_hosts文件中的主机IP地址,以检测由于DNS欺骗导致的主机密钥发生更改,且无论StrictHostKeyChecking的设置,都会将目标主机的地址增加到进程的~/.ssh/known_hosts中. Ciphers 指定支持的加密算法和偏好顺序.多个加密方式由逗号分隔.以’+’开头,会将指定的密码追加到默认集;以’-‘开头,将指定密码移除.支持的密码: 3DES-CBCAES128-CBCAES192-CBCAES256-CBCAES128-CTRAES192-CTRAES256-CTRaes128-gcm@openssh.comaes256-gcm@openssh.comchacha20-poly1305@openssh.com 默认为 chacha20-poly1305@openssh.com， AES128-CTR，AES192-CTR，AES256-CTR，AES128-GCM @ openssh.com，AES256-GCM @ openssh.com ClearAllForwardings 指定清楚配置文件或命令行指定的所有本地,远程和动态端口转发 Compression 指定是否压缩 ConnectionAttempts 指定退出尝试的次数(每秒一次) ConnectTimeout 指定连接到SSH服务器时使用的超时 ControlMaster 通过单个网络连接启用多个会话的共享 ControlPath 指定ControlMaster中用于连接共享的控制套接字的路径,或指定字符串none来禁用连接共享. ControlPersist 与ControlMaster配合使用,指定在初始客户端连接关闭后,主链接应在后台保持打开状态(等待将来的客户端连接) DynamicForward 指定通过安全通道转发本地计算机上的TCP端口,然后使用应用程序协议确定从远程计算机连接到的位置.参数为[bind_address:]port EnableSSHKeysign 在全局客户端配置文件/etc/ssh/ssh_config中设定,设定为yes,在主机验证方式时,看使用帮助程序 EscapeChar 设置转移字符 ExitOnForwardFailure 指定在无法及进行转发时,应该终止连接 FingerprintHash 指定显示密钥指纹的hash算法.可选项:md5和sha256(默认) ForwardAgent 指定身份验证代理连接是否将被转发到远程计算机 ForwardX11 指定是否通过安全通道自动重定向X11连接并进行显示设置 ForwardX11Trusted 设为yes,远程X11客户端将获得原始X11主机的完全访问权 GatewayPorts 指定是否允许元辰个主机连接到本地转发的端口.默认条件下,ssh将本地端口转发绑定到回传地址,以防止其他远程主机连接到转发的端口 GlobalKnownHostsFile 指定用于全局主机密钥数据库的一个或多个文件,用空格分隔.缺省值是/etc/ssh/ssh_known_hosts, /etc/ssh/ssh_known_hosts2 GSSAPIAuthentication 指定是否允许基于GSSAPI的用户认证 GSSAPIDelegateCredentials 转发(委托)凭据到服务器 HashKnownHosts 设定ssh将地址添加到~/.ssh/known_hosts时,是否hash主机名和地址 HostbasedAuthentication 指定是否尝试使用基于rhosts的公钥认证方法 HostbasedKeyTypes 以逗号分隔的模式列表指定基于主机的身份验证的密钥类型.默认值为: ecdsa-sha2-nistp256-cert-v01@openssh.com, ecdsa-sha2-nistp384-cert-v01@openssh.com, ecdsa-sha2-nistp521-cert-v01@openssh.com, ssh-ed25519-cert-v01@openssh.com, ssh-rsa-cert-v01@openssh.com, ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,ssh-ed25519,ssh-rsa HostKeyAlgorithms 指定客户端使用的主机密钥算法的顺序,默认值为: ecdsa-sha2-nistp256-cert-v01@openssh.com, ecdsa-sha2-nistp384-cert-v01@openssh.com, ecdsa-sha2-nistp521-cert-v01@openssh.com, ssh-ed25519-cert-v01@openssh.com, ssh-rsa-cert-v01@openssh.com, ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,ssh-ed25519,ssh-rsa可使用”ssh -Q key”查询可用密钥类型 HostKeyAlias 指定在主机密钥数据库文件中查看或保存主机密钥以及验证主机证书时,指定使用别名而不是实际主机名 Hostname 指定要登陆的真是主机名.可用来指定主机的昵称或缩写.参数接收TOKENS中的token.数字IP地址也是允许的.默认值是命令行中给出的名称 IdentitiesOnly 设定为ssh只能使用在shh_config文件中显式配置或在命令行上传递的身份认证和证书文件 IdentityAgent 指定用于与身份验证代理进行通信的UNIX-domain套接字.该选项覆盖SSH_AUTH_SOCK环境变量,可用于选择特定的代理.将套接字名称设置为”none”会禁用身份验证代理的使用.指定”SSH_AUTH_SOCK”将从SSH_AUTH_SOCK中读取位置 IdentityFile 指定读取用户的DSA,ECDSA,Ed25519或RSA认证标识的文件.默认值为~/.ssh/id_dsa. ~/.ssh/id_ecdsa, ~/.ssh/id_ed25519, ~/.ssh/id_rsa. IgnoreUnknown 如果在配置解析中遇到未知选项,则指定要忽略的未知选项的模式列表.尽早列在配置文件中(不会识别在其之前的未知选项) Include 包含指定的配置文件.可指定多个路径名,可含通配符,对用户配置,可用包含对用户主目录的’~’shell的引用.如果在系统配置文件中,包含/etc/ssh IPQoS 指定用于连接的IPv4服务类型或DSCP类.可用选择一个或两个参数,空格分隔.一个参数,用作包类;两个参数,第一个为交互式会话,第二个为非交互式会话 KbdInteractiveAuthentication 指定是否使用键盘交互身份验证方式 KbdInteractiveDevices 指定在键盘交互身份验证中使用的方法列表.多个方法名称用逗号分隔.可能是空或多个:bsdauth,pam和skey KexAlgorithms 指定可用的KEX(密钥交换)算法.多个算法用逗号分隔.默认值是: curve25519-sha256,curve25519-sha256@libssh.org, ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group-exchange-sha1,diffie-hellman-group14-sha256,diffie-hellman-group14-sha1 LocalCommand 指定成功连接到服务器后在本地计算机上执行的命令.命令字符串延伸到行的末尾,并于用户的shell一起执行 LocalForward 指定本地计算机上的TCP端口通过安全通道转发到远程计算机的指定主机和端口.第一个参数必须是[bind_address:]port,第二个参数必须是host:port.可通过将地址放在方括号中指定IPv6地址 LogLevel 提供从ssh记录消息时使用的详细级别 MACs 指定MAC算法的优先顺序.默认值为: umac-64-etm@openssh.com,umac-128-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com,hmac-sha1-etm@openssh.com, umac-64@openssh.com,umac-128@openssh.com,hmac-sha2-256,hmac-sha2-512,hmac-sha1 NoHostAuthenticationForLocalhost 禁用本地主机的主机认证(环回地址) NumberOfPasswordPrompts 指定放弃访问的密码尝试次数,默认为3 PasswordAuthentication 设定设否使用密码认证方法 PermitLocalCommand 允许通过LocalCommand选项执行本地命令或使用’!command’在ssh中转义 PKCS11Provider 指定选用的PKCS#11提供者.该关键字的参数是ssh用PKCS#11共享库与存储用户RSA私钥的PKCS#11令牌进行通信 Port 指定在远程主机上使用的端口号,默认为22 PreferredAuthentications 指定客户端尝试验证方法的顺序.这使得客户端可用选择更偏好的验证方法.默认值是: gssapi-with-mic,hostbased,publickey,keyboard-interactive,password ProxyCommand 指定用于连接到服务器的参数.命令字符串追加到行尾,并使用用户shell exec指令执行,以避免延迟shell进程.命令设置为none将禁用该选项.参数接受TOKENS中的token.冲动标准输入读取并写入标准输出.应连接到某台机器上运行的sshd服务器或在某处执行sshd -i ProxyJump 以[user@]host[:port]或ssh URI形式指定一个或多个跳转代理.多个代理可用逗号分隔,且会顺序访问.该选项导致ssh先于指定的跳板主机建立ssh连接,然后建立向最终目标的TCP转发,与目标主机建立连接 ProxyUseFdpass 指定ProxyCommand将连接的文件描述符传递回ssh,而不是继续执行并传递数据 PubkeyAcceptedKeyTypes 指定接收公钥的密钥类型,默认值为: ecdsa-sha2-nistp256-cert-v01@openssh.com, ecdsa-sha2-nistp384-cert-v01@openssh.com, ecdsa-sha2-nistp521-cert-v01@openssh.com, ssh-ed25519-cert-v01@openssh.com, ssh-rsa-cert-v01@openssh.com, ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,ssh-ed25519,ssh-rsa PubkeyAuthentications 设定是否使用公钥验证方法 RekeyLimit 指定在会话密钥重新协商之前可用传输的最大数据量,可选项指定最大时间.第一个参数是最大数据量,以字节为单位(K,M,G),默认值在1G到4G之间.第二个可选参数是最大时间,以秒为单位,可使用TIME FORMATS中指定的任何单位 RemoteCommand 指定成功连接到服务器后在远程计算机上执行的命令.命令字符串追加到行的末尾,并与用户的shell一起执行 RemoteForward 指定通过安全通道转发远程计算机上的TCP端口.远程端口可用从本地计算机转发到指定的主机和端口;也可用充当SOCK4/5代理使远程客户端从本地连接到任意目标.第一个参数必须是[bind_address:]port;如果转发到特定的目标,则第二个参数必须是host:hostport,如果没有指定目标参数,则远程转发将被建立SOCKS代理 可用通过将地址放在[]中指定IPv6地址.可用指定多个转发,并在命令行上提供额外的转发.只有在远程计算机上使用root身份登陆,才能转发特权端口 如果port参数为0,则监听端口将在服务器上动态分配并在运行时报告给客户端 如果未指定bind_address,则默认仅绑定到回传地址.如果bind_address是’*’或一个空字符串,则转发请求在所有端口上监听. RequestTTY 指定是否为会话请求伪终端.参数为:no,yes,force 或 auto. RevokedHostKeys 指定撤销的主机公钥.此文件中列出的密钥将会被拒绝进行主机验证.将密钥指定为文本文件,每行列出一个公钥.如果此文件不存在或不可读,则所有主机都将拒绝主机身份验证 SendEnv 指定应将哪些本地环境变量发送到服务器. ServerAliveCountMax 设置客户端未从服务器接收到任何返回信息的情况下服务器活动状态消息最大数量,达到数量时客户端端口服务器连接,并终止会话 ServerAliveInterval 设置以秒未单位的超时时间.超时后,如果没有从服务器收到数据,ssh将通过加密通道发送消息请求服务器的响应.默认为0,表示不发送 StreamLocalBindMask 设置为本地或远程端口转发创建Unix域套接字文件时的权限掩码umask.缺省值时0177,创建一个只能由所有者读写的Unix域套接字文件 StreamLocalBindUnlink 设置在创建新的Unix域套接字文件前是否删除现有的用于本地或远程端口转发的套接字文件 StrictHostKeyChecking 如果此标志设为”yes”,ssh将不会自动将主机密钥添加到~/.ssh/known_hosts文件,并拒绝连接到主机密钥已更改的主机.为避免中间人攻击提供保护. 如果设为”accept-new”,则ssh将自动将新主机密钥添加到用户已知的主机密钥,但不允许连接到已更改的主机. 如果设为”no”或”off”则ssh会自动将新主机密钥添加到用户已知主机文件中,并允许主机密钥更改的主机在限制条件下连接.如果设为”ask”,则只有在用户确认了该行为后才会将新主机密钥添加到用户已知主机文件中,并将拒绝主机密钥已改变的主机 SyslogFacility 给出记录ssh日志消息的设备代码.有效值为:DAEMON, USER, AUTH, LOCAL0, LOCAL1, LOCAL2, LOCAL3, LOCAL4, LOCAL5, LOCAL6, LOCAL7. 默认值是USER. TCPKeepAlive 指定系统是否向另一端发送TCP保持活动消息.发送该消息,如果连接死机或某台机器崩溃将会被反馈得知 Tunnel 在客户端和服务器之间请求设备转发.参数是: yes, point-to-point (第三层), ethernet (第二层), or no (默认).yes请求默认隧道模式,即point-to-point(点对点)模式 TunnelDevice 指定要在客户端(local_tun)和服务器(remote_tun)上打开的隧道tun设备.参数是local_tun[:remote_tun]这些设备可用数字ID或关键字”any”来指定.默认为any:any UpdateHostKeys 规定ssh是否接收来自其他服务器沿着国通的新增主机密钥通知并将其加入已知主机文件中. UsePrivilegedPort 规定是否将特权端口用于传出连接.默认为no,设为yes则ssh必须是root用户 User 指定登陆用户. UserKnownHostsFile 指定用于主机密钥数据库的一个或多个文件,用空格分隔.默认为~/.ssh/known_hosts, ~/.ssh/known_hosts2 VerifyHostKeyDNS 指定是否使用DNS和SSHFP资源记录验证远程密钥.设置为yes,客户端将默认信任来自DNS的能够匹配安全指纹的密钥,并与设为ask一样处理不安全的指纹.设为ask,将会显示有关指纹匹配的信息,但用户仍然需要根据StrictHostKeyChecking选项确认新的主机密钥. VisualHostKey 如果设为yes,则除了登陆时的指纹字符串和未知主机密钥意外,还会打印的ASCII art形式的远程主机密钥指纹 XAuthLocation 指定xauth程序的完整路径名 TOKENS(标记)参数接受的标记为: %% 字面的% %C %l%h%p%r的哈希值 %d 本地用户的home(~)目录 %h 远程主机名 %i 本地用户ID %L 本地主机名 %l 本地主机名,包含域名 %n 原始远程主机名,如命令行所示 %p 远程端口 %r 远程用户名 %T 如果请求隧道转发,则分配本地tun(4)或tap(4)网络接口,否则为&quot;NONE&quot; %u 本地用户名Match exec 接受标记: %%, %h, %L, %l, %n, %p, %r, 和 %u. CertificateFile 接受标记: %%, %d, %h, %l, %r, 和 %u. ControlPath 接受标记: %%, %C, %h, %i, %L, %l, %n, %p, %r, 和 %u.HostName 接受标记: %% 和 %h.IdentityAgent 和IdentityFile 接受标记: %%, %d, %h, %l, %r, 和 %u.LocalCommand 接受标记: %%, %C, %d, %h, %l, %n, %p, %r, %T, 和 %u.ProxyCommand 接受标记: %%, %h, %p, 和 %r.RemoteCommand 接受标记: %%, %C, %d, %h, %l, %n, %p, %r, 和 %u. 客户端进程ssh:OpenSSH SSH客户端(远程登陆程序) 命令ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface] [-b bind_address] [-c cipher_spec] [-D [bind_address:]port] [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file] [-J destination] [-L address] [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]] destination [command]参数解释-4 强制sshd仅使用IPv4地址 -6 强制sshd仅使用IPv6地址 -A 启用身份验证代理连接的转发.也可以在每个主机的基础配置文件中设定 -a 禁用转发身份验证代理连接 -B bind_interface 尝试连接到远程主机的监听bind_interface接口 -b bind_address 使用本地的bind_address作为连接的源地址 -C 请求压缩所有数据.压缩算法与gzip使用的算法相同 -c cipher_spec 选择用于加密会话的密码规范.按优先顺序列出以逗号分隔的密码列表 -D [bind_address:]port 指定本地动态应用层端口转发.通过分配一个套接字监听本地端口port,可选地绑定到指定的监听地址bind_address.只要连接到此端口,就会通过安全通道转发连接,然后使用应用层协议确定从远程计算机连接到本地的位置.目前支持SOCKS4和SOCKS5,ssh充当SOCKS服务器.只有root可以转发特权端口. -E log_file 将调试日志写入log_file中,而不输出到标准错误stderr中. -e escape_char 设置在pty上进行会话的转义符(默认为”*”).只有行首的转义符才会被识别.在转义符后跟一个点(‘.’)关闭连接;跟随control-Z暂停连接;跟随该字符本身,发送一个转义字符.将该项设为”none”将禁用任何转义 -F configfile 指定一个可选的单个用户的配置文件.如果在命令行上给出配置文件,则系统的配置文件(/etc/ssh/ssh_config)将被忽略.用户的默认配置文件是~/.ssh/config -f 请求ssh在命令执行前转到后台.在ssh询问口令或密码,但用户希望ssh在后台运行时很有用.在远程主机启动X11进程的推荐方式时使用ssh -f host xterm的方法 -G 让ssh在评估Host和Match块后打印其配置并退出 -g 运行远程主机连接到本地转发的端口.如果在多路复用连接上使用,则必须在主进程上指定此选项 -I pkcs11 指定ssh用于与PKCS#11令牌通信提供用户私钥所使用的PKCS#11共享库 -i identity_file 选择读取公钥认证方法的证明(即私钥)的文件.默认为~/.ssh/id_dsa, ~/.ssh/id_ecdsa, ~/.ssh/id_ed25519 和 ~/.ssh/id_rsa.私钥所在文件也可以在配置文件中以主机为目标指定.可以由多个-i选项(以及配置文件中指定的多个身份).如果CertificateFile项没有明确指定证书,则ssh会尝试从加载-cert.pub获得的文件名来识别加载证书文件 -J destination 先与destination描述的跳转主机进行ssh连接,然后在跳转主机建立到最终目的地的TCP转发,实现连接目标主机.可以用逗号字符指定多个跳转节点.时指定ProxyJump配置的快捷方法 -K 启用基于GSSAPI的身份验证并将GSSAPI凭据转发到服务器 -k 禁用GSSAPI凭据转发到服务器 -L [bind_address:]port:host:hostport-L [bind_address:]port:remote_socket-L local_socket:host:hostport-L local_socket:remote_socket 指定到本地主机(客户端)上给定TCP端口或Unix套接字的连接将转发到远程端的给定主机和端口或Unix套接字. -I login_name 指定要在远程计算机上登陆的用户. -M 将ssh客户端置为”master”模式进行连接共享 -m mac_spec MAC算法按优先级指定的逗号分隔列表 -N 不执行远程命令,对转发端口很有用 -n 重定向标准输入stdin到/dev/null(防止从stdin读取).在ssh在后台运行时必须使用 -O ctl_cmd 控制活动连接复用进程.指定-O参数时,将解释ctl_cmd参数并将其传递给主进程.有效命令是:”check”,”forward”,”cancel”,”exit”和”stop”. -o option 用于给出配置文件中使用的选项.选项列表为: AddKeysToAgentAddressFamilyBatchModeBindAddressCanonicalDomainsCanonicalizeFallbackLocalCanonicalizeHostnameCanonicalizeMaxDotsCanonicalizePermittedCNAMEsCertificateFileChallengeResponseAuthenticationCheckHostIPCiphersClearAllForwardingsCompressionConnectionAttemptsConnectTimeoutControlMasterControlPathControlPersistDynamicForwardEscapeCharExitOnForwardFailureFingerprintHashForwardAgentForwardX11ForwardX11TimeoutForwardX11TrustedGatewayPortsGlobalKnownHostsFileGSSAPIAuthenticationGSSAPIDelegateCredentialsHashKnownHostsHostHostbasedAuthenticationHostbasedKeyTypesHostKeyAlgorithmsHostKeyAliasHostNameIdentitiesOnlyIdentityAgentIdentityFileIPQoSKbdInteractiveAuthenticationKbdInteractiveDevicesKexAlgorithmsLocalCommandLocalForwardLogLevelMACsMatchNoHostAuthenticationForLocalhostNumberOfPasswordPromptsPasswordAuthenticationPermitLocalCommandPKCS11ProviderPortPreferredAuthenticationsProxyCommandProxyJumpProxyUseFdpassPubkeyAcceptedKeyTypesPubkeyAuthenticationRekeyLimitRemoteCommandRemoteForwardRequestTTYSendEnvServerAliveIntervalServerAliveCountMaxStreamLocalBindMaskStreamLocalBindUnlinkStrictHostKeyCheckingTCPKeepAliveTunnelTunnelDeviceUpdateHostKeysUsePrivilegedPortUserUserKnownHostsFileVerifyHostKeyDNSVisualHostKeyXAuthLocation -p port 远程主机连接的目标端口 -Q query_option 查询ssh以获得支持ssh2的算法.可用的功能有:cipher(受支持的堆成加密方法) ,cipher-auth(支持的认证加密方法) ,mac(支持的mac算法) ,kex(密钥交互算法) ,key(密钥类型) ,key-cert(证书密钥类型) ,key-plain(无证书密钥类型),和protocol-version(支持的SSH协议版本) -q: 静音模式.导致大多数警告和诊断消息不显示 -R [bind_address:]port:host:hostport-R [bind_address:]port:local_socket-R remote_socket:host:hostport-R remote_socket:local_socket-R [bind_address:]port 指定到远程主机(服务器)上给定的TCP端口或Unix套接字将被转发到本地端.通过分配套接字来监听TCP端口port或远程Unix套接字,并且从本地机器连接到由主机host或local_socket指定的显示目标;如果没有明确的目标指定,SSH作为一个SOCKS4/5代理 -S ctl_path 指定用于连接共享的控制套接字的位置,或者none禁用共享连接 -s 可用于请求调用远程系统上的子系统. -T 禁用伪终端分配 -t 强制伪终端分配.可用于在远程机器上执行任意基于屏幕的程序 -V 显示版本号并退出 -v 详细模式.使ssh打印有关进程的调试信息. -W host:port 请求在客户端的标准输入和标准输出通过安全通道转发到主机host上端口port -w local_tun[:remote_tun] 使用指定的tun设备在客户端(local_tun)和服务器(remote_tun)之间请求隧道转发 -X 启用X11转发 -x 禁用X11转发 -Y 启用可信的X11转发 -y 使用syslog系统模块发送日志信息.默认情况下,日志信息发送到stderr ssh-keygenssh-keygen:身份验证密钥生成,管理和转换 命令1. 1ssh-keygen [-q] [-b bits] [-t dsa | ecdsa | ed25519 | rsa] [-N new_passphrase] [-C comment] [-f output_keyfile] -q: 静默调用ssh-keygen 在创建新密钥时由/etc/rc调用 -b bits: 指定要创建的密钥的位数.RSA最小1024位,默认2048位.DSA必须符合FIPS 186-2规定的1024位.ECDSA通过从三个椭圆曲线大小中选择一个确定该密钥长度:256/384/521位(其他长度会失败).Ed25519具有固定长度,-b标志被忽略 -t dsa | ecdsa | ed25519 | rsa: 指定要创建的密钥的类型 -N new_passphrase: 提供新的密码 -C comment: 注释 -f filename(output_keyfile): 文件名,这里用于输出密钥的文件名 2. ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]-p: 请求更改私钥文件的密码.程序提示输入包含私钥的文件,旧密码以及新密码两次 -P passphrase(old_passphrase): 提供密码,这里用于提供旧密码 3. 1ssh-keygen -i [-m key_format] [-f input_keyfile] -i: 以-m选项指定的格式读取未加密的私钥/公钥文件,并将与OpenSSH兼容的私钥/公钥输出到标准输出stdout.允许从其他软件导入密钥.默认导入格式是”RFC4716” -m key_format: 指定导入(-i)或导出(-e)转换选项的密钥格式.支持的密钥格式是:”RFC4716”,”PKCS8”或”PEM”.默认的转换格式是”RFC4716” 4. 1ssh-keygen -e [-m key_format] [-f input_keyfile] -e: 读取OpenSSH公钥或私钥文件,并以-m选项指定的格式输出该密钥.默认的到处格式是”RFC4617”.允许到处OpenSSH密钥宫其他程序使用. 5. 1ssh-keygen -y [-f input_keyfile] -y: 读取一个OpenSSH格式私钥并输出对应的OpenSSH公钥文件 6. 1ssh-keygen -c [-P passphrase] [-C comment] [-f keyfile] -c: 请求更改私钥和公钥文件中的注释.仅支持比较新的OpenSSH格式存储的密钥.将提示输入包含私钥的文件,密钥的密码及新注释 7. 1ssh-keygen -l [-v] [-E fingerprint_hash] [-f input_keyfile] -l: 显示指定公钥的指纹.对于RSA和DSA密钥,会尝试查找匹配的公钥文件并打印其指纹.如果与-v结合使用个,会提供可视化的ASCII art形式的指纹图 -v: 详细模式.让ssh-keygen打印有关其进度的调试信息.多个-v选项增加详细程度,最大值为3 -E fingerprint_hash: 指定显示密钥指纹时的散列算法.有效选项:”md5”和”sha256”.默认为”sha256” 8. 1ssh-keygen -B [-f input_keyfile] -B: 显示指定私钥/公钥文件的bubble babble编码的摘要 9. 1ssh-keygen -D pkcs11 -D pkcs11: 下载由PKCS#11共享库pkcs11提供的RSA公钥.与-s一起使用,表示CA密钥主流在PKCS#11令牌中 10. 1ssh-keygen -F hostname [-f known_hosts_file] [-l] -F hostname: 在knewn_hosts文件中搜索指定的主机名hostname,列出找到的所有项.配合-H选项以hash格式打印找到的密钥 11. 1ssh-keygen -H [-f known_hosts_file] -H: hash一个known_hosts文件.将用指定文件中的hash表示体会所有主机名和地址;原始内容将被移到具有.old后缀的文件.hash值可以被ssh和sshd正常使用 12. 1ssh-keygen -R hostname [-f known_hosts_file] -R hostname: 从known_hosts文件中删除属于hostname的所有密钥 13. 1ssh-keygen -r hostname [-f input_keyfile] [-g] -r hostname: 打印指定公钥文件的hostname的SSHFP指纹资源记录 14. 1ssh-keygen -G output_file [-v] [-b bits] [-M memory] [-S start_point] -G output_file: 为DH-GEX生成候选素数.这些素数在使用前必须进行安全筛选(-T) -M memory: 为DH-GEX生成候选模数时,指定要使用的内存大小(以M字节为单位) -S start_point: 为DH-GEX生成候选模数时指定起始点(十六进制) 15. 1ssh-keygen -T output_file -f input_file [-v] [-a rounds] [-J num_lines] [-j start_line] [-K checkpt] [-W generator] -T output_file: 测试DH组交换候选素数(使用-G选项生成)以确保安全 -a rounds: 当保存新格式私钥(即ed25519密钥或设置-o选项)时,指定使用的KDF(密钥导出函数)循环次数.较高的次数导致密码验证较慢,但对清理密码破解的抵抗力增加. 当筛选DH-GEX候选模数时(-T命令).该选项指定要执行的素性测试的次数. -J num_lines: 在使用-T选项执行DH候选模数筛选时筛选指定的行数后退出 -K checkpt: 在使用-T选项执行DH候选模数筛选时将最后一行的筛选进程写入checkpt.如果作业重新启动,将用于跳过输入文件中已处理的行 -W generator: 在测试DH-DEX的候选模量时指定所需的发生器 16. 1ssh-keygen -s ca_key -I certificate_identity [-h] [-U] [-D pkcs11_provider] [-n principals] [-O option] [-V validity_interval] [-z serial_number] file ... -s ca_key: 使用指定的CA密钥对公钥进行认证(签名).在生成KRL时,-s指定用于通过密钥ID或序列号直接撤销证书的CA公钥文件的路径 -I certificate_identity: 签署公钥时指定密钥身份 -h: 签署密钥时,创建主机证书而不是用户证书 -U: 与-s一起使用时,此选项表示CA密钥主流在ssh-agent中 -n principals: 在签署密钥时指定一个或多个委托人(用户名或主机名)包含在证书中.可用指定多个委托人,以逗号分隔 -O option: 签署密钥时指定过一个证书选项.有效选项为: clear: 清除所有启用的权限critical:name[=contents]extension:name[=contents] 包含任意证书关键选项或扩展名.指定的name应包含域名后缀(“name@example.com“).如果contents被指定,它作为扩展名/选项的内容以字符串格式编码被包含.force-command=command 当使用证书进行身份验证时,强制执行command而不是用户指定的任何shell或命令no-agent-forwarding 禁用代理转发no-port-forwarding 禁用端口转发no-pty 禁用pty分配no-user-rc 禁用通过sshd执行/.ssh/rcno-X11-forwarding 禁用X11转发(以上禁用选项默认允许)permit-agent-forwarding 允许ssh-agent转发permit-port-forwarding 允许端口转发permit-port-pty 允许分配ptypermit-user-rc 允许通过sshd执行/.ssh/rcpermit-X11-forwarding 允许X11转发source-address=address_list 限制证书认为有效的源地址.ADDRESS_LIST时逗号分隔的CIDR格式的一个或多个地址/网络掩码对的列表 -V validity_interval: 签署证书时指定一个有效期间.一个有效时间间隔可用由单个时间组成,表面证书从现在开始有效并在那个时间到期;或由两个用冒号分隔指示明确的时间间隔 -z serial_number: 指定要嵌入证书中的序列号,以将此证书与同一CA中的其他证书区分开来.默认为0.当生成KRL时,-z标志用于指定KRL版本号 17. 1ssh-keygen -L [-f input_keyfile] -L: 打印一个或多个证书的内容 18. 1ssh-keygen -A [-f prefix_path] -A: 对于每个不存在主机密钥的密钥类型(rsa,dsa,ecdsa和ed25519),使用默认密钥文件路径,空密码,密码类型的默认位数和默认注释生成主机密钥.如果还指定-f,则其参数将用作生成规定主机密钥文件的默认路径的前缀.该项又/etc/rc用于产生新的主机密钥 19. 1ssh-keygen -k -f krl_file [-u] [-s ca_public] [-z version_number] file ... -k: 生成一个KRL文件.在该模式下,ssh-keygen将在通过-f标志指定的位置生成一个KRL文件,该文件撤销命令行中显示的每个密钥或证书. 20. 1ssh-keygen -Q -f krl_file file ... -Q: 测试密钥是否在KRL中被撤销. 模块生成ssh-keygen可用于为Diffie-Hellman组交换(DH-GEX)协议生成组.生成组的过程:先使用快速但内存密集的进程生成候选素数,然后对候选素数进行适应性测试(CPU密集型进程) 使用-G选项执行素数的生成,长度由-b选项指定 #ssh-keygen -G moduli-2048.candidates -b 2048默认情况下,搜索素数从所需长度范围内的随机点开始.可使用-S选项覆盖,指定不同的起点 产生了一组候选素数后,开始筛选适合性.使用-T选项执行.从标准输入(或-f指定文件)读取候选项. #ssh-keygen -T modulic-2048 -f moduli-2048.candidates默认情况下,每个候选素数将受到100次素性测试.可使用-a选项覆盖.如果需要特定的生成器,可用使用-W选项,有效的生成器是2,3,5 证书ssh-keygen支持签署密钥以生成可用用于用户或主机身份验证的证书.证书由公钥,身份信息,0或多个主体(用户或主机)名称以及证书颁发机构(CA)密钥签署的一组选项组成.然后,客户或服务器可用仅新人CA密钥并在证书上验证其签名. ssh-keygen支持两种类型的证书:用户和主机.用户证书将用户认证到服务器,主机证书向用户认证服务器主机 ssh-keyscanssh-keyscan 收集SSH公钥 ssh-keyscan 是一个用于收集各个主机的SSH主机公钥的程序.功能是帮助构建和验证ssh_known_hosts文件,其格式记录在sshd中.提供了一个适用于shell和perl脚本的最小界面 ssh-keyscan使用非阻塞套接字I/O来并行连接尽可能多的主机,因此非常搞笑.即使某些主机关闭或不运行sshd,也可以在几十秒内收集1000个主机域中的密钥 命令与参数1ssh-keyscan [-46cDHv] [-f file] [-p port] [-T timeout] [-t type] [host | addrlist namelist] 参数解释-4 强制ssh-keyscan 仅使用IPv4地址 -6 强制ssh-keyscan仅使用IPv6地址 -c 从目标主机请求证书而不是普通密钥 -D 打印以SSHFP DNS记录形式找到的密钥.默认将在ssh known_hosts文件可用格式下打印密钥 -f file 从file读取主机或”addrlist namelist”对.如果提供’-‘而不是文件名,ssh-keyscan将从标准输入中读取.预期输入的格式为: 1.2.3.4,1.2.4.4 name.my.domain,name,n.my.domain,n,1.2.3.4,1.2.4.4 -H 在输出中hash所有主机名和地址.hash名称可在ssh和sshd中正常使用,且公开后不会透漏任何关键信息 -p port 连接到远程主机的端口 -T timeout 设置尝试连接的超时时间.默认5秒 -t type 指定要从扫描的主机获取的密钥的类型.可能的值为: “dsa”, “ecdsa”, “ed25519”, 或 “rsa”. 默认为”rsa”,”ecdsa”和”ed25519” -v 详细模式:打印调试信息 ssh-keysignssh-keysign:用于基于主机的身份验证的ssh帮助程序 描述ssh使用ssh-keysign访问本地主机密钥,并生成在主机身份验证方式中需要的数字签名 ssh-keysign默认被禁用,只能通过在全局客户端配置文件/etc/ssh/ssh_config中配置选项EnableSSHKeysign为”yes”才会启用 ssh-keysign不会由用户调用,而是从ssh中调用 ssh-agentssh-agent 认证代理 ssh-agent 是一个保存用于公钥验证方式的私钥的程序.ssh-agent通常在X-session或登陆会话时启动,其他窗口或程序都作为ssh-agent的客户端启动.通过使用环境变量,代理可以被定为并在ssh登陆到其他机器时自动认证 ssh-agent最初没有任何私钥.使用ssh或ssh-add添加密钥.多个身份可用同时存储在ssh-agent中,且ssh会自动使用存在的身份.ssh-add也可以从ssh-agnet中移除密钥并查询保存在其中的密钥 命令与参数123ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash] [-P pkcs11_whitelist] [-t life] [command [arg ...]]ssh-agent [-c | -s] -k 参数解释-a bind_address 将代理绑定到UNIX域套接字bind_address.默认值为$TMPDIR/XXXXXXXXXX/agent. -c 在标准输出stdout上生成C-shell命令.如果shell看起来是csh风格的,这是默认项 -D 前景模式.在该选项被指定时,ssh-agent不会分叉 -d 调试模式.在该选项被指定时,ssh-agent不会分叉,并将调试信息写入标准错误stderr -E fingerprint_hash 指定打印密钥指纹时的散列算法.有效选项是:”md5”和”sha256”.默认值是”sha256” -k 杀掉当前代理(由SSH_AGENT_PID环境变量给出) -P pkcs11_whitelist 为可用使用-s选项添加到ssh-add的PKCS#11共享库指定可接受路径的模式列表.默认允许从“/usr/lib/*,/usr/local/lib/*”加载PKCS#11库.与白名单不匹配的PKCS#11库将被拒绝 -s 在标准输出stdout中生成Bourne shell命令.如果shell看起来不是csh风格的代码,则该项为默认项 -t life 为添加到代理的身份设定默认的最长生存周期.以秒或ssh_config中指定的时间格式为单位]]></content>
      <categories>
        <category>协议</category>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libssh]]></title>
    <url>%2F2019%2F06%2F19%2Flibssh%2F</url>
    <content type="text"><![CDATA[libssh库简介今天依旧是一篇旧文，还是ssh相关。ssh相关的开发大多是基于libssh库。本文关于libssh库的介绍，基本上也是对文档的翻译，时隔较旧，如有纰漏欢迎指正。 Chapter 1:SSH会话示例创建会话并设置选项1234567891011#include &lt;libssh/libssh.h&gt;#include &lt;stdlib.h&gt;int main()&#123; ssh_session my_ssh_session = ssh_new(); if (my_ssh_session == NULL) exit(-1); ssh_free(my_ssh_session);&#125; ssh_new()定义： 1ssh_session ssh_new(void) 返回一个ssh_session指针，错误时返回NULL 引用ssh_buffer_new()和ssh_set_blocking() ssh_buffer_new()定义： 1struct ssh_buffer_struct * ssh_buffer_new(void) 创建一个新的SSH缓冲区 返回新初始化的SSH缓冲区，错误时为NULL ssh_set_blocking()定义： 1void ssh_set_blocking (ssh_session session,int blocking) 将会话设置为阻塞/非阻塞模式 blocking 参数 0 设置为非阻塞模式 ssh_free()定义： 1void ssh_free(ssh_session session) 释放已分配的SSH会话句柄 libssh遵循allocate-it-deallocate-it模式，使用ssh_new()分配，必须使用ssh_free()进行取消分配 ssh_options_set()定义： 1int ssh_options_set(ssh_session session, enum ssh_optinons_e type, const void* value) 设置会话的选项 type：要设置的选项类型，常用的选项： SSH_OPTIONS_HOST:连接到的主机名或IP地址(const char*) SSH_OPTIONS_PORT:连接到的端口(unsigned int) SSH_OPTIONS_USER:想要连接的系统用户(const char*) SSH_OPTIONS_LOG_VERBOSITY:打印的消息数量(int) 其中SSH_OPTIONS_HOST是唯一的强制选项；端口号默认22；不使用SSH_OPTIONS_USER,则会使用当前账户的本地账用户名 连接到服务器完成设置后。可使用ssh_connect()进行连接。 12345678910111213141516171819202122232425#include &lt;libssh/libssh.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main()&#123; ssh_session my_ssh_session; int rc; my_ssh_session = ssh_new(); if (my_ssh_session == NULL) exit(-1); ssh_options_set(my_ssh_session,SSH_OPTIONS_HOST,"localhost")； rc = ssh_connect(my_ssh_session); if (rc!=SSH_OK) &#123; fprintf(stderr,"连接到本地主机错误：%s\n",ssh_get_error(my_ssh_session)); exit(-1); &#125; ssh_disconnect(my_ssh_session); ssh_free(my_ssh_session);&#125; ssh_connect()定义： 1int ssh_connect(ssh_session session) 连接到ssh服务器 成功时返回SSH_OK，错误时返回SSH_ERROR。若会话处于无阻塞模式，且必须要重连，返回SSH_AGAIN ssh_get_error()定义： 1const char* ssh_get_error(void* error) error ssh_session 或者 ssh_bind 返回描述错误的static字符串 ssh_disconnect()定义： 1void ssh_disconnect(ssh_session session) 从一个会话断开连接（服务器或客户端）；该会话之后可以在新的会话中重新开始使用。 与ssh_connect()组合使用 验证服务器连接完成后，必须检查刚刚连接的服务器是否一致且安全可用，有两种方式实现： （推荐）使用ssh_is_server_known()函数。该函数将查看已知的主机文件(UNIX中的~/.ssh/known_hosts)，查找服务器主机名的模式，并确认该主机是否存在列表中 使用ssh_get_pubkey_hash()函数。使用该函数获取二进制版本的公钥hash值，通过本地数据库检查此公钥是否已知且安全 ssh_is_server_known()定义： 1int ssh_is_server_known(ssh_session session) 返回一个状态码 ssh_get_pubkey_hash()定义： 1int ssh_get_pubkey_hash(ssh_session session, unsigned char** hash) 推荐使用ssh_get_publickey_hash() 如果时第一次使用远程主机，可以询问用户是否信任主机。如认为主机是有效的并且值得添加到已知主机文件中，可以使用ssh_write_knownhost()将其注册到已知主机文件中，或使用自己的数据库。 ssh_write_knownhost()定义： 1int ssh_write_knownhost(ssh_session session) 写入成功返回SSH_OK,失败则返回SSH_ERROR 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;error.h&gt;#include &lt;string.h&gt;int verify_knownhost(ssh_session session)&#123; int state,hlen; unsigned char *hash = NULL; char *hexa; char buf[10]; state = ssh_is_server_known(session);//是否识别远程主机 //获取远程主机的公钥hash hlen = ssh_get_pubkey_hash(session,&amp;hash); if (hlen&lt;0) return -1; //根据状态返回报错信息或进行下一步 switch(state) &#123; case SSH_SERVER_KNOWN_OK: break; case SSH_SERVER_KNOWN_CHANGED: fprintf(stderr,"Host key for server changed:it is now:\n")； ssh_print_hexa（"Public key hash",hash,hlen); fprintf(stderr,"For security reasons, connection will be stopped\n"); free(hash); return -1; case SSH_SERVER_FOUND_OTHER: fprintf(stderr, "The host key for this server was not found but an other type of key exists.\n"); fprintf(stderr, "An attacker might change the default server key to confuse your client into thinking the key does not exist\n"); free(hash); return -1; case SSH_SERVER_FILE_NOT_FOUND: fprintf(stderr, "Could not find known host file.\n"); fprintf(stderr, "If you accept the host key here, the file will be automatically created.\n"); case SSH_SERVER_NOT_KNOWN: hexa = ssh_get_hexa(hash, hlen); fprintf(stderr,"The server is unknown. Do you trust the host key?\n"); fprintf(stderr, "Public key hash: %s\n", hexa); free(hexa); if (fgets(buf, sizeof(buf), stdin) == NULL) &#123; free(hash); return -1; &#125; if (strncasecmp(buf, "yes", 3) != 0) &#123; free(hash); return -1; &#125; if (ssh_write_knownhost(session) &lt; 0) &#123; fprintf(stderr, "Error %s\n", strerror(errno)); free(hash); return -1; &#125; break; case SSH_SERVER_ERROR: fprintf(stderr,"Error %s\n",ssh_get_error?(session)); free(hash); return -1; &#125; free(hash); return 0;&#125; ssh_get_error_code()定义： 1int ssh_get_error_code(void* error) 用于接受最后一个错误的错误代码 返回一个错误代码，对应不同错误状态 验证用户在用户验证服务器是安全可用的远程主机后，下一步是服务器授权用户，使已认证的用户能够访问资源。 libssh支持的认证方法： 无认证 密码方法 键盘交互方式：服务器向用户发出几个挑战，用户必须正确回答问题。志告方式使通过密码本验证成为可能 公钥方法 这些认证方式可以结合使用。 一个使用密码进行身份验证的实例： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;libssh/libssh.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main()&#123; ssh_session my_ssh_session; int* rc; char* password; my_ssh_session = ssh_new(); if (my_ssh_session == NULL) exit(-1); ssh_options_set(my_ssh_session,SSH_OPTIONS_HOST,"localhost"); rc = ssh_connect(my_ssh_session); if (rc!=SSH_OK) &#123; fprintf(stderr,"Error connecting to localhost:%s\n",ssh_get_error(my_ssh_session)); ssh_free(my_ssh_session); exit(-1); &#125; if (verify_knowhost(my_ssh_session)&lt;0) &#123; ssh_disconnect(my_ssh_session); ssh_free(my_ssh_session); exit(-1); &#125; password = getpass("Password:"); rc = ssh_userauth_password(my_ssh_session,NULL,password); if(rc!=SSH_AUTH_SUCCESS) &#123; fprintf(stderr,"Error authenticating with password:%s\n",ssh_get_error(my_ssh_session)); ssh_disconnect(my_ssh_session); exit(-1); &#125; ssh_disconnect(my_ssh_session); ssh_free(my_ssh_connect);&#125; 操作在双方进行验证后，下一步可以利用SSH协议进行操作，执行远程命令，开启远程终端，交换文件，转发端口；等等。 执行远程命令的示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344int show_remote_processes(ssh_session session)&#123; ssh_channel channel' int rc; char buffer[256]; int nbytes; channel = ssh_channel_new(session); if (channel == NULL) return SSH_ERROR; rc = ssh_channel_open_session(channel); if (rc != SSH_OK) &#123; ssh_channel_close(channel); ssh_channel_free(channel); return rc; &#125; nbytes = ssh_channel_read(channel,buffer,sizeof(buffer),0); while(nbytes &gt; 0) &#123; if (write(1,buffer,nbytes)!= (unsigned int)nbytes) &#123; ssh_channel_close(channel); ssh_channel_free(channel); return SSH_ERROR; &#125; nbytes = ssh_channel_read(channel,buffer,sizeof(buffer),0); &#125; if(nbytes &lt; 0) &#123; ssh_channel_close(channel); ssh_channel_free(channel); return SSH_ERROR; &#125; ssh_channel_send_eof(channel); ssh_channel_close(channel); ssh_channel_free(channel); return SSH_OK;&#125; Chapter 2:用户验证相关公钥，密码，挑战应答模式（键盘交互），无验证 公钥验证方法libssh与openssh公钥和私钥完全兼容，可以使用libssh提供的自动公钥验证方法，也可以使用公钥函数进行自定义。 验证流程 扫描本地包含公钥的文件列表，每个密钥都发送到SSH服务器，直到服务器确认一个密钥（服务器已知的可以认证用户的密钥）。 检索此密钥的私钥并发送证明自己知道该私钥的消息。 使用ssh_userauth_publickey_auto()函数进行验证 ssh_userauth_publickey_auto()定义： 1int ssh_userauth_publickey_auto(ssh_session session,const char* username,const char* passphrase) 尝试自动使用公钥或无验证方式进行验证 参数： session SSH会话 username 用户名，应该为NULL passphrase 密码，用于解锁私钥，如果不使用密码或需要询问用户时用NULL 返回值： SSH_AUTH_ERROR:发生严重错误 SSH_AUTH_DENIED:服务器不接受该公钥验证，尝试另一个公钥或其他方法 SSH_AUTH_PARTIAL:已经被部分认证（多验证方式存在），仍需要其他验证方法 SSH_AUTH_SUCCESS:公钥通过验证，可以使用ssh_userauth_publickey() SSH_AUTH_AGAIN:非阻塞模式下，须稍后再重新调用 ssh_userauth_publickey()定义： 1int ssh_userauth_publickey(ssh_session session,const char* username,const ssh_key privkey) 使用公钥/私钥或证书进行验证，与用户的私钥进行身份验证匹配 大多数服务器实现不允许在认证过程中更改用户名，只有在连接到服务器之前才应该使用ssh_options_set()来设置用户名，username参数应该设置为NULL 使用自己的公钥进行身份验证步骤： 使用ssh_pki_import_pobkey_file()检索公钥 使用ssh_userauth_try_publickey()将公钥提供给SSH服务器。如果返回值为SSH_AUTH_SUCCESS，则SSH服务器接受使用公钥进行身份验证，则进行下一步 使用ssh_userauth_publickey()与私钥进行身份验证 最后使用ssh_key_free()清理内存 ssh_pki_import_pubkey_file()定义： 1int ssh_pki_import_pubkey_file(const char* filename,ssh_key* pkey) 参数： filename 公钥文件的地址 pkey 存储公钥分配的指针，需要使用ssh_key_free()释放内存 返回值： 成功时返回SSH_OK；文件不存在或者权限被拒绝返回SSH_EOF；其他返回SSH_ERROR ssh_userauth_try_publickey()定义: 1int ssh_userauth_try_publickey(ssh_session session,const char* username,const ssh_key pubkey) 尝试使用给定的公钥进行身份验证 ssh_pki_import_privkey_file()定义： 1int ssh_pki_import_privkey_file(const char* filename,const char* passphrase,ssh_auth_callback auth_fn,void* auth_data,ssh_key* pkey) 从文件中个导入密钥 参数： filename:私钥名称 passphrase:私钥的解密密钥。未加密或未知设为NULL auth_fn:希望使用的验证函数或为NULL auth_data:传递给验证函数的私有数据 Pkey:分配给存储ssh_key的指针，需要使用ssh_key_free()释放 返回值： 成功时返回SSH_OK；文件不存在或者权限被拒绝返回SSH_EOF；其他返回SSH_ERROR ssh_key_free()定义: 1void ssh_key_free(ssh_key key) 释放一个SSH key 一个示例1234567891011121314int authenticate_pubkey(ssh_session session)&#123; int rc; rc = ssh_userauth_publickey_auto(session NULL); if (rc = SSH_AUTH_ERROR) &#123; fprintf(stderr,"Authentication failed: %s\n",ssh_get_error(session)); return SSH_AUTH_ERROR; &#125; return rc;&#125; 密码验证使用ssh_userauth_password()进行密码身份验证。若密码通过验证，返回SSH_AUTH_SUCCESS。需要询问密码并进行安全分配管理。 如果服务器反馈密码错误，但仍可以使用openssh的客户端进行身份验证，可能是因为openssh只接受键盘交互形式的验证。切换到键盘交互模式，或尝试在SSH服务器上配置纯文本密码。 ssh_userauth_password()定义： 1int ssh_userauth_password(ssh_session session,const char* username,const char* password) 尝试使用密码进行验证；该方法通常在SSHv2服务器上被禁止，应当使用键盘交互模式进行验证。 password值必须用UTF-8进行编码，如何与解释密码，并与密码数据库进行验证由服务器决定。 键盘交互认证方法服务器提出challenge，一个或多个用户必须回答的问题，直到服务器接受认证 ssh_userauth_kbdint()定义： 1int ssh_userauth_kbdint(ssh_session session,const char* user,const char* submethods) 尝试通过键盘交互模式进行验证。 参数： session：将要使用的ssh会话 user：需要验证的用户名，定义为NULL，有ssh_option_set_username()修改用户名，中途不能修改 submethods：设定为NULL 返回： SSH_AUTH_ERROR:发生严重错误 SSH_AUTH_DENIED:认证失败：使用另一种方法 SSH_AUTH_PARTIAL:部分认证成功，仍需要其他方法的认证 SSH_AUTH_SUCCESS:认证成功 SSH_AUTH_INFO:服务器询问了一些问题，使用ssh_userauth_kbdint_getnprompts() SSH_AUTH_AGAIN:在无阻塞模式中，需要之后再重新访问 ssh_userauth_kbdint_getnprompts()定义： 1int ssh_userauth_kbdint_getprompts(ssh_session session) 获取服务器提供的提示(问题)数量 返回： 提示的数量 ssh_userauth_kbdint_getname()定义： const char* ssh_userauth_kbdint_getname(ssh_session session)获得消息块的名称。调用ssh_userauth_kbdint()并收到了SSH_AUTH_INFO返回码，调用该函数检索远程主机发送的键盘交互认证问题的信息。 返回：消息快的名称，不要释放该指针 ssh_userauth_kbdint_getinstruction()定义： 1const char* ssh_userauth_kbdint_getinstruction(ssh_session session) 获取消息块的指令 返回：消息块的指令 ssh_userauth_kbdint_getprompt()定义： 1const char* ssh_userauth_kbdint_getprompt(ssh_session session,unsigned int i,char* echo) 从消息块获取提示 参数： session 使用的ssh会话 i 当前提示的索引 echo 可选项，获取一个布尔值，用于设定用户输入应该被回显或隐藏，密码通常设定为隐藏 返回：指向提示符的指针，不要释放该指针 ssh_user_kbdint_setanswer()定义： 1int ssh_userauth_kbdint_setanswer(ssh_session session,unsigned int i,const char* answer) 回复来自消息块的问题的答案 参数： session 当前会话 i 当前提示的索引编号 answer 给服务器的答案，必须为UTF-8格式的编码。如何解释并使用该值进行验证取决于服务器，但如果使用其他格式编码答案，则必须先转换为UTF-8 返回：成功时返回0，错误时返回值&lt;0 认证过程 调用ssh_userauth_kbdint()函数并存储答案 如果收到的返回是SSH_AUTH_INFO，则说明服务器发送了几个问题，询问用户，使用ssh_userauth_kbdint_getnprompts(),ssh_userauth_kbdint_getname(),ssh_userauth_kbdint_getinstruction()和ssh_userauth_kbdint_getprompt()检索问题 使用ssh_userauth_kbdint_setanswer()为挑战中的每个问题设置答案 再次调用ssh_userauth_kbdint()，直到这些函数返回的内容不是SSH_AUTH_INFO 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//为当前会话进行键盘交互方式的认证int authenticate_kbdint(ssh_session session)&#123; int rc;//状态码 rc = ssh_userauth_kbdint(session,NULL,NULL) while(rc == SSH_AUTH_INFO)//调用直到返回值不是SSH_AUTH_INFO &#123; const char *name,*instruction; int nprompts,iprompt; //检索问题，获取问题的名称，指令，提示 name = ssh_userauth_kbdint_getname(session); instruction = ssh_userauth_kbdint_getinstruction(session); nprompts = ssh_userauth_kbdint_getnprompts(session); if (strlen(name)&gt;0) printf("%s\n",name); if (strlen(instruction)&gt;0) printf("%s\n",instruction); for (iprompt = 0;iprompt &lt; nmprompts;iprompt++)//循环获取所有的提示，并获取用户的答案 &#123; const char *prompt; char echo; prompt = ssh_userauth_kbdint_getprompt(session,iprompt,&amp;echo);//检索提示，将内容赋给prompt if (echo)//如果设定为真，显示用户回显 &#123; char buffer[128], *ptr; printf("%s",prompt); if (fgets(buffer,sizeof(buffer),stdin)==NULL)//用户未能回答问题，则验证失败 return SSH_AUTH_ERROR; buffer[sizeof(buffer)-1] = '\0';//将缓存中的最后一位置为标志'\0' if ((ptr = strchr(buffer,'\n'))!=NULL) *ptr = '\0'; if (ssh_userauth_kbdint_setanswer(session,ipromot,buffer)&lt;0)//如果服务器验证未通过，返回失败 return SSH_AUTH_ERROR; memset(buffer,0,strlen(buffer));//将缓存区置空 &#125; else//设定为隐藏模式，以密码形式读取 &#123; char *ptr; ptr = getpass(prompt); if (ssh_userauth_kbdint_setanswer(session,iprompt,ptr)&lt;0) return SSH_AUTH_ERROR; &#125; &#125; rc = ssh_userauth_kbdint(session,NULL,NULL); &#125; return rc;&#125; 使用“无验证”模式无验证模式主要目的是在没有任何凭证的情况下进行认证（除非确实要授权匿名访问权限，不要使用该方式）。 如果该账号没有密码，且服务器配置为允许通过，则ssh_userauth_none()可能回复SSH_AUTH_SUCCESS ssh_userauth_none()定义： 1int ssh_userauth_none(ssh_session session,const char* username) 示例1234567int authenticate_kbdint(ssh_session session)&#123; int rc; rc = ssh_userauth_none(session,NULL); return rc;&#125; 获取支持的身份验证列表如果不选择指定某种验证方法，可以让服务器展示可以是使用的验证方法 使用ssh_userauth_list()函数获取可用的身份验证方法以及如何使用 ssh_userauth_list()定义： 1int ssh_userauth_list(ssh_session session,const char* username) 获取服务器可使用的验证方法，调用该函数前需要调用ssh_userauth_none() 返回： SSH_AUTH_METHOD_PASSWORD SSH_AUTH_METHOD_PUBLICKEY SSH_AUTH_METHOD_HOSTBASED SSH_AUTH_METHOD_INTERACTIVE 获取横幅SSH服务器可能会发送一个横幅，一般为免责声明等内容用，使用ssh_get_issue_banner()检索横幅，显示给用户 ssh_get_issue_banner()定义： 1char* ssh_get_issue_banner(ssh_session session) 返回分配给横幅的字符串指针，出错时返回NULL 示例123456789101112131415161718int display_banner(ssh_session session)&#123; int rc; char *banner; rc = ssh_userauth_none(session,NULL); if (rc = SSH_AUTH_ERROR) return rc; banner = ssh_get_issue_banner(session); if (banner) &#123; printf("%s\n",banner); free(banner); &#125; return rc;&#125; Chapter 3:开启远程终端一个SSH连接可以有多个信道共享。一个信道可以用于多种用途。可以创建信道，用于开启远程终端，在远程计算机上启动命令解释程序。 打开和关闭信道使用ssh_channel_new()函数创建一个信道，创建好之后，使用ssh_channel_open_session()打开一个SSH会话。不需要该信道时，使用ssh_channel_close()发送文件结束符(eof)，此时可以通过ssh_channel_free()销毁信道 ssh_channel_new()定义： 1ssh_channel ssh_channel_new(ssh_session session) 分配一个新的信道 返回：指向新分配的信道的指针，错误时返回NULL ssh_channel_open_session()定义： 1int ssh_channel_open_session(ssh_channel channel) 参数：channel：分配好的信道 返回： SSH_OK 成功时返回 SSH_ERROR 错误时返回 SSH_AGAIN 无阻塞模式下，需要等待重新调用 ssh_channel_close()关闭一个信道，发送文件结束符(EOF)并关闭信道。关闭后无法恢复无法去要发送或处于缓冲区中的数据 返回：成功返回SSH_OK，失败返回SSH_ERROR ssh_channel_free()关闭并释放一个信道 定义： 1void ssh_channel_free(ssh_channel channel) 调用函数后该信道上的所有数据均会丢失 示例12345678910111213141516171819202122int shell_session(ssh_session session)&#123; ssh_channel channel; int rc; channel = ssh_channel_new(session); if (channel == NULL) return SSH_ERROR; rc = ssh_channel_open_session(channel); if (rc != SSH_OK) &#123; ssh_channel_free(channel); return rc; &#125; ssh_channel_close(channel); ssh_channel_send_eof(channel); ssh_channel_free(channel); return SSH_OK;&#125; 交互会话与非交互会话如果需要一个接一个地键入命令，则认为是交互模式的；如果没有附加终端，类似于后台执行命令，是为为交互式的shell. 如果使用交互式shell。需要在远程终端创建一个伪终端，通过ssh_channel_request_pty()请求pty，然后用ssh_channel_change_pty_size()定义其维度(行数和列数） 无论使用交互会话还是非交互会话，都需要使用ssh_channel_request_shell()请求一个shell ssh_channel_request_pty()定义： 1int ssh_channel_request_pty(ssh_channel channel) 请求一个伪终端PTY 返回：成功时返回SSH_OK，失败时返回SSH_ERROR,在非阻塞模式下如果需要重新调用返回SSH_AGAIN ssh_channel_change_pty_size()定义： 1int ssh_channel_change_pty_size(ssh_channel channel,int cols,int rows) 改变远程终端的大小 参数： channel 使用的信道 cols 分配的列数 rows 分配的行数 返回：成功时返回SSH_OK，失败时返回SSH_ERROR warning： 如果不确定使用相同信道/会话的其他libssh函数是否在同一时间运行(不是100%线程安全)，则不要从信号处理程序调用该函数 ssh_channel_request_shell()定义： 1int ssh_channel_request_shell(ssh_channel channel) 请求一个shell 返回：成功时返回SSH_OK，失败时返回SSH_ERROR,在非阻塞模式下如果需要重新调用返回SSH_AGAIN 示例123456789101112131415int interactive_shell_session(ssh_channel channel)&#123; int rc; rc = ssh_channel_request_pty(channel); if (rc!=SSH_OK) return rc; rc = ssh_channel_change_pty_size(channel,80,24); if (rc!=SSH_OK) return rc; rc = ssh_channel_request_shell(channel); if (rc!=SSH_OK) return rc; return rc;&#125; 显示远程计算机发送的数据在程序中通常要接受来自远程终端的数据，需要进行分析，记录或显示 使用ssh_channel_read()和ssh_channel_read_nonblocking()从信道中读取数据 ssh_channel_read()定义： 1int ssh_channel_read(ssh_channel channel,void* dest,uint32_t count,int is_stderr) 从信道中读取数据 参数： channel 读取数据的来源信道 dest 接受数据的目标缓存区 count 读取的数据大小 is_stderr 标准错误流stderr中的内容的布尔值标志 返回： 读取的数据的字节数，在错误时返回0或EOF标记或SSH_ERROR。在无阻塞模式在无可用数据或接受到SSH_AGAIN时返回0 warning： 函数可能返回小于count字节的数据，并在count字节被读取之前不会被阻塞。使用缓存区的读取函数重命名为channel_read_buffer() 示例123456789101112131415161718192021222324252627int interactive_shell_session(ssh_channel channel)&#123; int rc; string buffer[256]; int nbytes; rc = ssh_channel_request_pty(channel); if (rc!=SSH_OK) return rc; rc = ssh_channel_change_ptu_size(channel,80,24); if (rc!=SSH_OK) return rc; rc = ssh_channel_request_shell(channel); if (rc!=SSH_OK) return rc; while(ssh_channel_is_open(channel)&amp;&amp;!ssh_channel_is_eof(channel)) &#123; nbytes = ssh_channel_read(channel,buffer,sizeof(buffer),0); if (nbytes&lt;0) return SSH_ERROR; if (nbytes&gt;0) write(1,buffer,nbytes); &#125; return rc;&#125; 像远程主机发送用户输入使用ssh_channel_write()向远程站点发送数据 ssh_channel_write()定义： 1int ssh_channel_write(ssh_channel channel,const void* data,uint32_t len) 向信道写入块数据 参数： channel 将要写入的信道 data 指向要写入的数据的指针 len 写入的缓冲区的长度 返回：写入的字节数；出错时返回SSH_ERROR 示例12345678910111213141516171819202122232425262728293031323334353637383940414243int kbhit()&#123; struct timeval tv = &#123;0L,0L&#125; fd_set fdsl FD_ZERO(&amp;fds); FD_SET(0,&amp;fds); return select(1,&amp;fds,NULL,NULL,&amp;tv);&#125;//用于Linux系统下检测键盘输入，Windows下是标准函数，不能重复定义 有键盘输入返回1，否则为0int interactive_shell_session(ssh_channel channel)&#123; char buffer[256]; int nbytes,nwritten; while (ssh_channel_is_open(channel)&amp;&amp;!ssh_channel_is_eof(channel))//信道开启且不是结束符 &#123; nbytes = ssh_channel_read_nonblocking(channel,buffer,sizeof(buffer),0); if (nbytes &lt; 0) return SSH_ERROR; if (nbytes &gt; 0) &#123; nwritten = write(1,buffer,nbytes); if (nwritten != nbytes) return SSH_ERROR; &#125; if (!kbhit())//如果键盘没有输入，挂起进程等待0.05秒 &#123; usleep(50000L); continue; &#125; nbytes = read(0,buffer,sizeof(buffer)); if (nbytes &lt; 0) return SSH_ERROR; if (nbytes &gt; 0) &#123; nwritten = ssh_channel_write(channel,buffer,nbytes); if (nwritten != nbytes) return SSH_ERROR; &#125; &#125; return rc;&#125; ssh_channel_is_open()定义： 1int ssh_channel_is_open(ssh_channel channel) 检查信道是否开启 返回：信道关闭返回0，其他情况返回非0值 在远程终端使用图形界面图形界面的远程终端，可以通过X11协议将图形界面转发到本地 首先声明接受ssh_channel_accept_x11()的X11连接，然后使用ssh_channel_request_x11为X11协议创建转发隧道 ssh_channel_accept_x11()定义: 1ssh_channel ssh_channel_accept_x11(ssh_channel channel,int timeout_ms) 接受X11转发信道 参数： channel 允许X11会话的信道 timeout_ms 微秒为单位的超时值 返回：新建立的信道，或当没有从服务器来的X11请求时返回NULL ssh_channel_request_x11()定义： 1int ssh_channel_request_x11(ssh_channel channel,int single_connetion,const char* protocol,const char* cookie,int screen_number) 通过现有的会话信道发送X11(x11-req)请求，将远程X11应用的显示重定向到本地X服务器 参数： channel 一个用来执行X11程序的现有会话信道 single_connection 标记是否只有单个X11应用被重定向的布尔值 protocol X11身份认证协议，传递NULL使用默认值MIT-MAGIC-COOKIE-1 cookie X11协议cookie，传递NULL生成你随机cookie screen_number 屏幕号 返回：成功时返回SSH_OK,出错时返回SSH_ERROR，非阻塞模式下需要重新调用返回SSH_AGAIN 示例1234567891011121314151617int interactive_shell_session(ssh_channel channel)&#123; int rc; ssh_channel x11channel; rc = ssh_channel_request_pty(channel); if (rc != SSH_OK) return rc; rc = ssh_channel_change_pty_size(channel,80.24); if (rc != SSH_OK) return rc; rc = ssh_channel_request_x11(channel,0,NULL,NULL,0); if(rc != SSH_OK) return rc; rc = ssh_channel_request_shell(channel); if (rc = !=SSH_OK) return rc;&#125; Chapter4:传递远程命令该方法只适用于执行一个远程命令，如果要发出多个命令，应使用非交互式远程shell 执行远程命令1.打开一个SSH信道1234567891011121314int show_remote_files(ssh_session session)&#123; ssh_channel channel; int rc; channel = ssh_channel_new(session); if (channel == NULL) return SSH_ERROR;//创建一个信道 rc = ssh_channel_open_session(channel); if (rc != SSH_OK) &#123; ssh_channel_free(channel);//如果不能开启会话，释放掉当前信道 return rc; &#125; 2.执行远程命令调用ssh_channel_request_exec()执行远程命令 1234567rc = ssh_channel_request_exec(channel,"ls -l");if (rc != SSH_OK)&#123; ssh_channel_close(channel); ssh_channel_free(channel); return rc;&#125; ssh_channel_request_exec() 定义： 1int ssh_channel_request_exec(ssh_channel channel,const char* cmd) 运行一条没有交互式shell的shell命令，类似于执行’sh -c command’ 参数： channel 执行命令的信道 cmd 执行的命令 返回：成功时返回SSH_OK,出错时返回SSH_ERROR，非阻塞模式下需要重新调用返回SSH_AGAIN 3.获取数据远程命令显示数据，调用ssh_channel_read()获取数据。改善书返回读取的字节数。如果信道上没有更多数据，则函数返回0，转到下一步；如果月到错误，则返回负值。 123456789101112131415161718192021char buffer[256];int nbytes;nbytes = ssh_channel_read(channel,buffer,sizeof(buffer),0);while (nbytes &gt; 0)&#123; if (fwrite(buffer,1,bytes,stdout)！=nbytes) &#123; ssh_channel_close(channel); ssh_channel_free(channel); return SSH_ERROR; &#125; nbytes = ssh_channel_read(channel,buffer,sizeof(buffer),0);&#125;if (nbytes &lt; 0)&#123; ssh_channel_close(channel); ssh_channel_free(channel); return SSH_ERROR;&#125; 4.结束读取远程命令的结果后，将文件结束符EOF发送到信道，关闭信道并释放信道 12345ssh_channel_send_eof(channel);ssh_channel_close(channel);ssh_channel_free(channel);return SSH_OK Chapter 5:SFTP子系统SFTP是安全文件传输协议的简称,可以用于本地与远程计算机的远程传输.SFTP的功能丰富,现有的版本是版本3,虽然未解决全部功能,但核心功能已经实现 打开和关闭SFTP会话SFTP子系统不是打开一个SSH信道,而是开启一个SFTP会话 用sftp_new()创建一个新的SFTP会话,用函数sftp_free()初始化,sftp_free()删除. 示例12345678910111213141516171819202122232425#include &lt;libssh/sftp.h&gt;int sftp_helloworld(ssh_session session)&#123; sftp_session sftp; int rc; sftp = sftp_new(session); if (sftp = NULL) &#123; fprintf(stderr,"Error allocationg SFTP session:%s\n",ssh_get_error(session)); return SSH_ERROR; &#125; rc = sftp_init(sftp); if (rc != SSH_OK) &#123; fprintf(stderr,"Error initializing SFTP session:%s.\n",sftp_get_error(sftp)); sftp_free(sftp); return rc; &#125; sftp_free(sftp); return SSH_OK;&#125; sftp_new()定义: sftp_session sftp_new(ssh_session session)返回:正确分配一个sftp会话或错误时返回NULL 需要使用stfp_free()进行释放 sftp_init()定义: 1int sftp_init(sftp_session sftp) 参数:sftp:将要初始化的sftp会话 返回:成功时返回0,失败时返回&lt;0的值并抛出ssh错误 sftp_free()定义: 1void sftp_free(sftp_session sftp) 关闭并释放一个sftp会话 SFTP错误产生错误时,除ssh_get_error_number()抛出常规SSH错误外,使用sftp_get_error()返回SFTP错误号 sftp_get_error()定义: 1int sftp_get_error(sftp_session sftp) 获取最后一个错误 返回:保存的错误,如果函数出错返回&lt;0 错误编号 SSH_FX_OK: 无错误 SSH_FX_\EOF: 遇到文件结束符EOF SSH_FX_NO_SUCH_FILE: 文件不存在 SSH_FX_PERMISSION_DENIED: 权限被拒绝 SSH_FX_FAILURE: 通配失败 SSH_FX_BAD_MESSAGE: 从服务器收到garbage SSH_FX_NO_CONNECTION: 未建立链接 SSH_FX_CONNECTION_LOST: 存在链接但已丢失 SSH_FX_OP_UNSUPPORTED: 操作不受libssh支持 SSH_FX_INVALID_HANDLE: 无效的文件句柄 SSH_FX_NO_SUCH_PATH: 不存在此文件或目录 SSH_FX_FILE_ALREADY_EXISTS: 尝试创建已经存在的文件或目录 SSH_FX_WRITE_PROTECT: 写保护的文件系统 SSH_FX_NO_MEDIA: 远程驱动中没有介质 创建一个目录通过sftp_mkdir()创建目录,目录权限和mkdir函数相同.所需的权限与远程用户的掩码组合确定有效权限 示例12345678910111213141516171819#include &lt;libssh/sftp.h&gt;#include &lt;sys/stat.h&gt;int sftp_helloworld(ssh_session session,sftp_session sftp)&#123; int rc; rc = sftp_mkdir(sftp,"helloworld",S_IRWXU); if (rc!=SSH_OK) &#123; if (sftp_get_error(sftp)!=SSH_FX_FILE_ALREADY_EXISTS) &#123; fprintf(stderr,"无法创建目录:%s\n",ssh_get_error(session)); return rc; &#125; &#125; return SSH_OK;&#125; sftp_mkdir()定义: 1int sftp_mkdir(sftp_session sftp,const char* directory,mode_t mode) 创建目录 参数: sftp sftp会话的句柄 diretory 将要创建的目录 mode 指定要使用的权限.由进程的umask掩码进行修饰,通常以创建文件的(mode&amp;~umask)(即mode与用户掩码umask进行位与后的结果)方式决定权限 返回:成功时返回0,错误时返回&lt;0并抛出ssh和sftp错误 与SCP系统中不同,该函数不会将当前目录切换到新创建的目录中 向远程计算机拷贝文件可以像处理本地文件一样处理远程文件的内容:以特定模式打开文件,移动文件指针,读取或写入数据以及关闭文件 调用sftp_open()函数,该函数类似与本地的open()函数,并额外返回一个sftp_file类型的文件句柄,该文件句柄可以由其他文件操作函数使用,并保持有效直到调用sftp_close()关闭该远程文件 示例123456789101112131415161718192021222324252627282930313233343536#include &lt;libssh/sftp.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int sftp_helloworld(ssh_session session,sftp_session sftp)&#123; int access_type = O_WRONLY | O_CREAT | O_TRUNC; sftp_file file;//open()函数参数设定,写模式,不存在文件新建,以存在文件,长度被截为0 const char *helloworld = "Hello,World!\n"; int length = strlen(helloworld); int rc,nwritten; file = sftp_open(sftp,"helloworld/helloworld.txt",access_type,S_IPWXU); if (file == NULL) &#123; fprintf(stderr,"Can't open file for writing:%s\n",ssh_get_error(session)); return SSH_ERROR; &#125; nwritten = sftp_write(file,helloworld,length); if (nwritten != length) &#123; fprintf(stderr,"Can't write data to file:%s\n",ssh_get_error(session)); sftp_close(file); return SSH_ERROR; &#125; rc = sftp_close(file); if (rc != SSH_OK) &#123; fprintf(stderr,"Can't close the written file:%s\n",ssh_get_error(session)); return rc; &#125; return SSH_OK;&#125; sftp_open()定义: 1sftp_file sftp_open(sftp_session session,const char* file,int accessype,mode_t mode) 在远程服务器打开(创建)文件 参数: session sftp会话句柄 file 将要打开的文件(指针) accesstype open函数参数,指定文件操作类型等参数 mode 如果要创建新文件,指定要使用的权限.由进程的umask掩码进行修饰,通常以创建文件的(mode&amp;~umask)(即mode与用户掩码umask进行位与后的结果)方式决定权限 返回:成功时返回文件句柄(指针),错误时返回NULL并抛出ssh和sftp错误 sftp_close()定义: 1int sftp_close(sftp_file file) 释放指针关闭打开的文件句柄 返回:正常关闭时返回SSH_NO_\ERROR,发生错误是返回SSH_ERROR 从远程计算机读取文件通过sftp读取网络文件,可以通过同步或一部两种方式完成 同步读取使用sftp_read()完成 同步读取文件调用sftp_read()函数.文件通常以块形式传输,一个好的文件块大小是16KB. 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//以16KB文件块远程打开"/etc/profile"文件#define MAX_XFER_BUF_SIZE 16384 //16KBint sftp_read_sync(ssh_session session,sftp_session sftp)&#123; int access_type; sftp_file file; char buffer[MAX_XFER_BUF_SIZE]; int nbytes,nwritten,rc; int fd; access_type = O_RDONLY; file = sftp_open(sftp,"etc/profile",access_type,0); if (file == NULL) &#123; fprintf(stderr,"Can't open file for reading:%s\n",ssh_get_error(session)); return SSH_ERROR; &#125; fd = open("/path/to/profile",O_CREAT); if (fd &lt; 0) &#123; fprintf(stderr,"Can't open file for writing:%s\n",strerror(session)); return SSH_ERROR; &#125; for(;;)//读取文件块直到缓存区为空 &#123; nbytes = sftp_read(file,buffer,sizeof(buffer)); if (nbytes == 0) &#123; break; &#125; else if (nbytes &lt; 0) &#123; fprintf(stderr,"Error while reading file:%s\n",ssh_get_error(session)); sftp_close(file); return SSH_ERROR; &#125; nwritten = write(fd,buffer,nbytes); if (nwritten != nbytes) &#123; fprintf(stderr,"Error writing:%s\n",strerror(errno)); sftp_close(file); return SSH_ERROR; &#125; &#125; rc = sftp_close(file); if (rc != SSH_OK) &#123; fprintf(stderr,"Can't close the read file:%s\n",ssh_get_error(session)); return rc; &#125; return SSH_OK;&#125; sftp_read() 定义: 1ssize_t sftp_read(sftp_file file,void* buf,size_t count) 从打开的文件句柄(文件指针)中读取文件 参数: file 打开的文件指针 buf 接收文件内容的缓存区指针 count 以字节为单位的缓存区大小 返回:写入的数据字节数,发生错误时返回&lt;0并抛出ssh和sftp错误 异步读取数据异步读取分两步完成,首先调用sftp_asyns_read_begin(),返回一个请求句柄 然后调用sftp_async_read(),使用该句柄.如果文件以非阻塞模式打开,则该函数可能会返回SSH_AGAIN,此时请求尚未完成,需要稍后重新调用.否则调用sftp_async_read()等待数据到来 以非阻塞模式打开文件,需要在打开文件后立即调用sftp_set_nonblocking()函数(默认时阻塞模式) 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#define MAX_XFER_BUF_SIZE 16384int sftp_read_async(ssh_session,sftp_sesison sftp)&#123; int access_type; sftp_file file; char buffer [MAX_XFER_BUF_SIZE]; int async_request; int nbytesl long counter; int rc; access_type = O_RDONLY; file = sftp_open(sftp,"some_very_big_file",access_type,0); if (file == NULL) &#123; fprintf(stderr,"Can't open file for reading:%s\n",ssh_get_error(session)); return SSH_ERROR; &#125; sftp_file_set_nonblocking(file); async_request = sftp_async_read_begin(file,sizeof(buffer)); counter = 0L; usleep(10000); if (async_request &gt;= 0) &#123; nbytes = sftp_async_read(file,buffer,sizeof(buffer),async_request); &#125; else &#123; nbytes = -1; &#125; while (nbytes &gt; 0)||nbytes == SSH_AGAIN) &#123; if (nbytes &gt; 0) &#123; write(1,buffer,nbytes); async_request = sftp_async_read_begin(file,sizeof(buffer)); &#125; else &#123; counter++; &#125; usleep(10000); if (async_request &gt;= 0) &#123; nbytes = sftp_async_read(file,buffer,sizeof(buffer),async_request); &#125; else &#123; nbytes = -1; &#125; &#125; if (nbytes &lt; 0) &#123; fprintf(stderr,"Error while reading file:%s\n",ssh_get_error(session)); sftp_close(file); return SSH_ERROR; &#125; printf("The counter has reached value: %ld\n",counter); rc = sftp_close(file); if (rc != SSH_OK) &#123; fprintf(stderr,"Can't close the read file:%s\n",ssh_get_error(session)); return rc; &#125; return SSH_OK;&#125; sftp_async_read_begin() 定义: 1int sftp_async_read_begin(sftp_file file,uint32_t len) 使用打开的sftp文件句柄进行异步读取.目标是避免与同步读取方式/响应模式相关的慢速读取 参数: file 读取的打开的文件句柄 len 将要读取的字节数 返回:与发送的请求对应的响应符,错误时返回&lt;0 warning: 调用该函数时,内部偏移量将会根据len参数进行更新,调用该函数会向服务器发送请求,若服务器应答,libssh非配内存存储响应,直到sftp_async_read()被调用.如果不调用sftp_async_read()会导致内存泄漏 sftp_async_read() 定义: 1int sftp_async_read(sftp_file file,void* data,uint32_t len,uint32_t id) 等待异步传输读取完成并保存数据 参数: file 将要被读取的文件句柄 data 指向接收数据的缓存区的指针 len 以字节为单位的缓存区的大小,应该大于等于sftp_async_read_begin()调用的长度参数 id sftp_async_read_begin()返回的标识符 返回:读取的字节数;遇到EOF文件结束符返回0;错误时返回SSH_ERROR;阻塞模式返回SSH_AGAIN并需要之后再次访问 warning: 使用无效标识符调用该函数将永远不会返回 sftp_file_set_nonblocking() 定义: 1void sftp_file_set_nonblocking(sftp_file handle) 将传入的文件句柄设置为无阻塞通信模式 列出目录的内容使用handle_type:sftp_dir的句柄类型,访问正在读取的目录 sftp_opendir()定义: 1sftp_dir sftp_opendir(sftp_session session,const char* path) 打开一个用于获取远程目录条目的目录 参数: session 打开目录的sftp句柄 path 将要打开的目录地址 返回:成功时返回目录的sftp句柄 错误时返回NULL并抛出ssh和sftp错误 sftp_readdir()定义: 1sftp_attributes sftp_readdir(sftp_session,sftp_dir dir) 获取目录的单个文件属性结构 参数: session 将要读取的目录的sftp会话句柄 dir 将要读取的目录的sftp句柄 返回:文件属性结构,出错或目录结尾处返回NULL 文件属性结构 即一个sftp_attributes类型,是一个指向具有目录条目信息结构的指针: name:目录或文件的名称 size:以比特为单位的大小 等等其他属性 在出错或目录结尾处可能会返回NULL.通过sftp_dir_eof()判断是否目录结尾 不需要时,必须用sftp_attributes_free()释放属性 sftp_dir_eof()定义: 1int sftp_dir_eof(sftp_dir dir) 确定是否达到了文件结束符EOF 参数:dir sftp目录句柄 返回:是EOF时返回1,不是则返回0 sftp_closedir()定义: 1int sftp_closedir(sftp_dir dir) 关闭目录句柄 返回:SSH_NO_ERROR或SSH_ERROR sftp_attributes_free()定义: 1void sftp_attributes_free(sftp_attributes file) 释放sftp属性结构的指针 示例123456789101112131415161718192021222324252627282930313233343536int sftp_list_dir(ssh_session,sftp_session sftp)&#123; sftp_dir dir; sftp_attributes attributes; int rc; dir = sftp_opendir(sftp,"/var/log"); if (!dir) &#123; fprintf(stderr,"Directory not opened:%s\n",ssh_get_error(session)); return SSH_ERROR; &#125; printf("Name Size Perms Owner\tGroup\n"); while((attributes = sftp_readdir(sftp,dir)) != NULL) &#123; printf("%-20s %10llu %.8o %s(%d)\t%s(%d)\n",attributes-&gt;name,(long long unsigned int)attributes-&gt;size,attributes-&gt;permissions,attributes-&gt;owner,attributes-&gt;uid,attributes-&gt;group,attributes-&gt;gid); sftp_attributes_free(attributes); &#125; if (!sftp_dir_eof(dir)) &#123; fprintf(stderr,"Can't list directory: %s\n",ssh_get_error(session)); sftp_closedir(dir); return SSH_ERROR; &#125; rc = sftp_closedir(dir); if (rc != SSH_OK) &#123; fprintf(stderr,"Can't close directory: %s\n",ssh_get_error(session)); return rc; &#125;&#125; Chapter 6:SCP子系统SCP子系统的功能远远少于SFTP子系统,但如果只需要从远程系统复制文件,SCP可以胜任 开启/关闭SCP会话SCP子系统中,不直接操作SSH信道,而是开启一个SCP会话 SCP会话中不能同时进行读和写的操作,需要在调用ssh_scp_new()函数时指定读写模式 另一个重要的模式参数是SSH_SCP_RECURSIVE,声明是否使用递归读取目录的方式 ssh_scp_new()创建会话,ssh_scp_init()进行初始化.完成传输后,使用ssh_scp_close()终止SCP链接,并调用ssh_scp_free()释放分配的连接 示例1:递归写入123456789101112131415161718192021222324int scp_write(ssh_session session)&#123; ssh_scp scp; int rc; scp = ssh_scp_new(session,SSH_SCP_WRITE|SSH_SCP_RECURSIVE,"."); if (scp == NULL) &#123; fprintf(stderr,"Error allocating scp session:%s\n",ssh_get_error(session)); return SSH_ERROR; &#125; rc = ssh_scp_init(scp); if (rc != SSH_OK) &#123; fprintf(stderr,"Error initializing scp session: %s\n"); ssh_scp_free(scp); return rc; &#125; ssh_scp_close(scp); ssh_scp_free(scp); return SSH_OK;&#125; 示例2:打开连接读取单个文件123456789101112131415161718192021222324int scp_read(ssh_session session)&#123; ssh_scp scp; int rc; scp = ssh_scp_new(session,SSH_SCP_READ,"hello/helloworld.txt"); if (scp == NULL) &#123; fprintf(stderr,"Error allocating scp session: %s\n",ssh_get_error(session)); return SSH_ERROR; &#125; rc = ssh_scp_init(scp); if (rc != SSH_OK) &#123; fprintf(stderr,"Error initializing scp session: %s\n",ssh_get_error(session)); ssh_scp_free(scp); return rc; &#125; ssh_scp_close(scp); ssh_scp_free(scp); return SSH_OK;&#125; ssh_scp_new()定义: 1ssh_scp ssh_scp_new(ssh_session session,int mode,const char* location) 创建一个新的scp会话 参数: session 使用的SSH会话 mode 标志位 SSH_SCP_WRITE/SSH_SCP_READ,选择读/写模式.SSH_SCP_RECURSIVE可以通过位或运算添加到参数中,表示可以递归操作(访问目录必须) location 写入或读取的目录 返回:ssh_scp句柄,失败时返回NULL ssh_scp_init()定义: 1int ssh_scp_init(ssh_scp scp) 初始化一个scp信道 返回:成功时返回SSH_OK,失败时返回SSH失败码 ssh_scp_close()关闭scp信道 参数: scp 要关闭的scp连接 返回: 成功时返回SSH_OK,失败时返回SSH错误码 ssh_scp_free()定义: 1void ssh_scp_free(ssh_scp scp) 释放scp上下文 创建文件和目录创建目录:调用ssh_scp_push_diretory()创建目录.在递归模式下,创建目录后会直接进入该目录.如果目录已经存在,且处于递归模式,直接输入该目录即可 创建文件:分为两步,先调用ssh_scp_push_file()准备写入;然后调用ssh_scp_write()写入数据.两个函数间要写入的数据长度必须相同. 不需要打开/关闭文件操作,远端自动完成此操作.如果文件已经存在,将会被覆盖并截断 示例1234567891011121314151617181920212223242526272829int scp_helloworld(ssh_session session,ssh_scp scp)&#123; int rc; const char *helloworld = "Hello\n"; int length = strlen(helloworld); rc = ssh_scp_push_diretory(scp,"helloworld",S_IRWXU); if (rc != SSH_OK) &#123; fprintf(stderr,"Can't create remote diretory: %s\n",ssh_get_error(session)); return rc; &#125; rc = ssh_scp_push_file(scp,"helloworld.txt",length,S_IRUSR|S_IWUSR); if (rc != SSH_OK) &#123; fprintf(stderr,"Can't open remote file: %s\n",ssh_get_error(session)); return rc; &#125; rc = ssh_scp_write(scp,helloworld,length); if (rc != SSH_OK) &#123; fprintf(stderr,"Can't write to remote file: %s\n",ssh_get_error(session)); return rc; &#125; return SSH_OK;&#125; ssh_scp_push_directory()定义: 1int ssh_scp_push_diretory(ssh_scp scp,const char* dirname,int mode) 在sink模式下创建一个目录 参数: scp scp句柄 dirname 将要创建的目录名 mode UNIX权限数值 返回:成功创建目录返回SSH_OK,出错时返回SSH_ERROR ssh_scp_push_file()定义: 1int ssh_scp_push_file(ssh_scp scp,const char* filename,size_t size,int mode) 初始化文件传输 参数: scp scp句柄 filename 将要传输的文件名,不应包含任何路径信息 size 发送文件的字节大小 mode 新文件的UNIX权限 返回:如果文件准备好发送,返回SSH_OK;发生错误返回SSH_ERROR ssh_scp_write()定义: 1int ssh_scp_write(ssh_scp scp,const void* buffer,size_t len) 写入远程文件 参数: scp scp句柄 buffer 将要写入的缓存区 len 将要吸入的字节数 返回:写入成功返回SSH_OK,发生错误返回SSH_ERROR 读取文件和目录要接收文件,可以调用ssh_scp_pull_request()向远程端发起请求. 如果函数返回SSH_SCP_REQUEST_NEWFILE,则必须准备好接收文件. 可以调用ssh_scp_request_get_size()获取文件大小并据此分配缓存区. 准备好接收文件后,发送ssh_scp_accept_request(),然后调用ssh_scp_read()读取数据 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int scp_receive(ssh_session session,ssh_scp scp)&#123; int rc; int size,mode; char *filename, *buffer; rc = ssh_scp_pull_request(scp); if (rc != SSH_SCP_REQUEST_NEWFILE) &#123; fprintf(stderr,"Error receiving information about file: %s\n",ssh_get_error(session)); return SSH_ERROR; &#125; size = ssh_scp_request_get_size(scp); filename = strdup(ssh_scp_request_get_filename(scp)); mode = ssh_scp_reqiest_get_permissions(scp); printf("Receiving file %s, size %d, permissions 0%o\n",filename,size,mode); free(filename); buffer = malloc(size); if (buffer == NULL) &#123; fprintf(stderr,"Memory allocation error\n"); return SSH_ERROR; &#125; ssh_scp_accept_request(scp); rc = ssh_scp_read(scp, buffer, size); if (rc = SSH_ERROR) &#123; fprintf(stderr,"Error receiving file data: %s\n",ssh_get_error(session)); free(buffer); return rc; &#125; printf("Done\n"); write(1, buffer, size); free(buffer); rc = ssh_scp_pull_request(scp); if (rc != SSH_SCP_REQUEST_EOF) &#123; fprintf(stderr,"Unexpected request: %s\n",ssh_get_error(session)); return SSH_ERROR; &#125; return SSH_OK;&#125; ssh_scp_pull_request()定义: 1int ssh_scp_pull_request(ssh_scp scp) 等待一个scp请求(文件,目录) 返回: SSH_SCP_REQUEST_NEWFILE:另一端在传输一个文件 SSH_SCP_REQUEST_NEWDIR:另一端在传输一个目录 SSH_SCP_ENDDIR:另一端完成了当前目录的传输 SSH_SCP_REQUEST_WARNING:另一端发送了一个警告 SSH_SCP_REQUEST_EOF:另一端完成了文件和数据的传输 SSH_ERROR:发生了错误 ssh_scp_request_get_size()定义: 1size_t ssh_scp_request_get_size(ssh_scp scp) 获取另一端传输的文件的大小 返回:将要读取的文件的大小 Warining: 实际大小可能不适合32位文件域,可能会发生截断 ssh_scp_accept_request()定义: 1int ssh_scp_accept_request(ssh_scp scp) 接收远程主机传输的文件或创建目录 返回:SSH_OK;SSH_ERROR ssh_scp_read()定义: 1int ssh_scp_read(ssh_scp scp,void* buffer,size_t size) 读取远程文件 参数: scp scp句柄 buffer 目标缓存区 size 缓存区的大小 返回:读取的字节数;错误时返回SSH_ERROR ssh_scp_leave_directory()定义: 1int ssh_scp_leave_diretory(ssh_scp scp) 离开一个目录 返回:SSH_OK;SSH_ERROR 从远程服务器接收完整的目录数以递归模式打开SCP会话,远程端会告知何时更改目录 调用ssh_scp_pull_request()返回SSH_SCP_REQUEST_NEWDIRECTORY时,应使用该本地目录输入;返回SSH_SCP_REQUEST_ENDDIRECTORY时,应离开当前目录. Chapter7: 转发连接(隧道)端口转发采用两种不同的SSH协议:直接或反向端口转发.直接端口转发即本地端口转发,反向端口转发即远程端口转发 直接端口转发直接端口转发时从客户端向服务器的转发.客户端打开一个隧道,并将任何数据转发给服务器;然后服务器连接到一个终点,终点口语主流在另一台机器或SSH服务器本身上 流程app-&gt;本地端口-&gt;SSH客户端 ===&gt;SSH服务器-&gt;远程端口-&gt;目标app示例Mail client application Google Mail | ^ 5555 (任意端口) | | 143 (IMAP2) V | SSH client =====&gt; SSH server 图例: --P--&gt;: 通过端口P连接端口 =====&gt;: SSH隧道邮件客户端连接到客户端的端口5555,客户端向服务器建立加密隧道.服务器连接到Google邮件服务器的143端口(终点).本地邮件服务器可以向远程发送邮件 实现1234567891011121314151617181920212223242526272829int direct_forwarding(ssh_session session)&#123; ssh_channel forwarding_channel; int rc; char *http_get = "GET / HTTP/1.1\nHost: www.google.com\n\n"; int nbytes, nwritten; forwarding_channel = ssh_channel_new(session); if (forwarding_channel == NULL) return rc; rc = ssh_channel_open_forward(forwarding_channel,"www.google.com",80,"localhost",5555); if (rc != SSH_OK) &#123; ssh_channel_free(forwarding_channel); return rc; &#125; nbytes = strlen(http_get); nwritten = ssh_channel_write(forwarding_channel,http_get,nbytes); if (nbytes != nwritten) &#123; ssh_channel_free(forwarding_channel); return SSH_ERROR; &#125; ssh_channel_free(forwarding_channel); return SSH_OK;&#125; ssh_channel_open_forward()定义: 1int ssh_channel_open_forward(ssh_channel channel,const char* remotehost,int remoteport,const char* sourcehost,int localport) 端口一个TCP/IP转发信道 参数: channel 分配的信道 remotehost 将要连接的远程地址(域名或IP) remoteport 远程端口 sourcehost 连接请求的来源主机的数字IP.主要用于记录 localport 发起连接的来源主机的端口.主要用于记录 返回:SSH_OK;SSH_ERROR;SSH_AGAIN; Warning: 该函数不绑定本地端口,也不会自动将套接字的内容发送到信道,仍需要调用channel_read()和channel_write() ssh_select()定义: 1int ssh_select(ssh_channel* channels, ssh_channel* outchannels, socket_t maxfd, fd_set* readfds, struct timeval* timeout) 选择系统调用的封装 与select(2)有些类似.不支持重写或异常处理 参数: channels 信道数组的指针由NULL终止,永不支持重写 outchannels 和信道相同大小的数组,不需要初始化 maxfd 来自readfds的最大文件描述符+1 readfds 被选择用于读取的文件描述符fd_set timeout 毫秒单位超市 返回:SSH_OK;SSH_ERROR;被打断时返回SSH_EINTR,重新开始即可 Warning: libssh在此不可重入(递归调用).意味着在调用此函数时收到了信号,时柄口语调用其他libssh函数的 反向端口转发远程端口转发是有服务器发起的,从服务器向客户端转发,即使客户端主动建立隧道.一旦隧道建成,服务器将持续监听某个端口,一旦端口产生连接,服务器向客户端转发数据 流程远程app-&gt;监听端口-&gt;SSH服务器 ===&gt; SSH客户端-&gt;本地端口-&gt;本地app 示例 Local mail server Mail client application ^ | | 5555 (任意端口) 143 (IMAP2) | | V SSH client &lt;===== SSH server 图例: --P--&gt;: 通过端口P连接端口 =====&gt;: SSH信道客户端建立隧道,但将用于将服务器上建立的连接转发给客户端 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162int web_server(ssh_session session)&#123; int rc; ssh_channel channel; char buffer[256]; int nbytes, nwritten; int port = 0; char *helloworld = """HTTP/1.1 200 OK\n""Content-Type: text/html\n""Content-Length: 113\n""\n""&lt;html&gt;\n"" &lt;head&gt;\n"" &lt;title&gt;Hello, World!&lt;/title&gt;\n"" &lt;/head&gt;\n"" &lt;body&gt;\n"" &lt;h1&gt;Hello, World!&lt;/h1&gt;\n"" &lt;/body&gt;\n""&lt;/html&gt;\n"; rc = ssh_channel_listen_forward(session, NULL, 8080, NULL); if (rc != SSH_OK) &#123; fprintf(stderr, "Error opening remote port: %s\n", ssh_get_error(session)); return rc; &#125; channel = ssh_channel_accept_forward(session, 60000, &amp;port); if (channel == NULL) &#123; fprintf(stderr, "Error waiting for incoming connection: %s\n", ssh_get_error(session)); return SSH_ERROR; &#125; while (1) &#123; nbytes = ssh_channel_read(channel, buffer, sizeof(buffer), 0); if (nbytes &lt; 0) &#123; fprintf(stderr, "Error reading incoming data: %s\n", ssh_get_error(session)); ssh_channel_send_eof(channel); ssh_channel_free(channel); return SSH_ERROR; &#125; if (strncmp(buffer, "GET /", 5)) continue; nbytes = strlen(helloworld); nwritten = ssh_channel_write(channel, helloworld, nbytes); if (nwritten != nbytes) &#123; fprintf(stderr, "Error sending answer: %s\n", ssh_get_error(session)); ssh_channel_send_eof(channel); ssh_channel_free(channel); return SSH_ERROR; &#125; printf("Sent answer\n"); &#125; ssh_channel_send_eof(channel); ssh_channel_free(channel); return SSH_OK;&#125; ssh_channel_listen_forward()定义: 1int ssh_channel_listen_forward(ssh_session session, const char* address, int port, int* bound_port) 发送”tcpip-forward”全局请求要求服务器开始监听入站连接 参数: session 发送请求的ssh会话 address 将要监听的服务器上的地址.发送NULL监听服务器支持的所有协议族的所有可用地址 port 要在服务器上绑定的端口.传递0让服务器分配下一个可以的非特权端口 bound_port 获取实际绑定端口的指针.传递NULL忽略该项 返回:SSH_OK;SSH_ERROR;SSH_AGAIN ssh_channel_accept_forward()定义: 1ssh_channel ssh_channel_accept_forward(ssh_session session, int timeout_ms, int* destination_port) 接收传入的TCP/IP转发信道,并获取有关传入连接的信息 参数: session 使用的ssh会话 timeout_ms 以毫秒为单位的超时 destination_port 指向目的端口或NULL指针 返回:新创建的信道或NULL X11隧道流程图形应用程序(X11客户端)-&gt;SSH服务器 ===&gt; SSH客户端 -&gt;本地展示(X11服务器) 由客户端创建SSH信道 Chapter8: 使用libssh的线程libssh可以用于多线程应用程序,但注意: 线程必须在初始化libssh期间初始化,该初始化必须在任何线程上下文以为完成 如果应用程序使用pthreads,则必须链接libssh_threads动态库并使用ssh_threads_pthreads线程对象初始化线程 如果应用程序正在使用其他线程库,则必须实现ssh_threads_callbacks_struct机构的所有方法,并用它初始化libssh 任何时候都可以在线程内部使用不同的会话,并行连接,在不同会话中读/写等.但不能在多个进程中使用单个会话(或单个会话的信道) 线程初始化先调用ssh_threads_set_callbacks()选择要使用的线程模型,然后调用ssh_init() 1234#include &lt;libssh/callback.h&gt;ssh_threads_set_callbacks(ssh_threads_get_noop());ssh_init(); ssh_threads_noop时不执行任何操作的线程结构,时不适用线程时默认使用的线程回调 ssh_threads_set_callbacks()定义: 1int ssh_threads_set_callbacks(struct ssh_threads_callbacks_struct* cb) 设置线程回调结构 如果要以多线程方式使用libssh,则该函数时必须的.在调用ssh_init()之前,必须调用该函数,而不是在线程上下文 参数:cb 指向ssh_threads_callbacks_struct结构的指针,包含要设置的不同回调 返回:总返回SSH_OK 在libssh中使用libpthread1234#include &lt;libssh/callbacks.h&gt;ssh_threads_set_callbacks(ssh_threads_get_pthread());ssh_init(); 必须确保与ssh_threads链接.如果使用gcc,必须使用命令行 gcc -o output input.c -lssh -lssh_threads]]></content>
      <categories>
        <category>协议</category>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh-protocol]]></title>
    <url>%2F2019%2F06%2F18%2Fssh-protocol%2F</url>
    <content type="text"><![CDATA[SSH协议这是一篇去年学习ssh协议时写的文，基本上是SSH标准协议的翻译，放上来仅供参考，里边的一些细节我也有些忘记了。 概述SSH是Secure SHell的缩写，即安全外壳协议，是一种在不安全网络提供安全远程登陆以及其他安全网络服务的协议。SSH是建立在应用层基础上的安全协议，可以有效防止远程管理过程中的信息泄露问题。 功能主要功能提供网络服务程序功能，加密传输数据，可抵抗中间人攻击。 应用场景 替代Telnet进行远程通信 提供安全FTP服务 为POP、PPP协议提供安全信道 组成SSH协议由三个子协议组成：传输层协议(SSH-TRANS)、用户认证协议(SSH-USERAUTH)、连接协议(SSH-CONNECT) SSH-TRANS功能安全的低级传输协议。提供服务器认证，保密性和完整性，还提供压缩功能。 通常运行在TCP/IP连接上，也可用于其他可靠数据流上。 身份验证是居于主机的，不执行用户认证，更高层的用户认证协议可以基于此协议设计。 规范端口通过TCP/IP使用时，端口默认为22 协议版本交换标识字符串： SSH-protoversion-softwareversion SP comments CR LF‘protoversion’是”2.0”（现多为SSH2版本），’comments’字符串可选，若包含’comments’字符串,SP字符(空格符,ASCII 32)务必将’softwareversion’和’comments’字符串分开。标识字符串必须由单个CR字符(回车符，ASCII 13)和单个LF字符（换行符，ASCII 10）终止。 字符串中不能出现其他的空字符，最大长度为255个字符(包含回车和换行)，在回车和换行(CR LF)之前的标识字符串部分用于Diffie-Hellman密钥交换。 实例： SSH-2.0-OpenSSH CR LF兼容性服务端为新版本，客户端为旧版本时，服务端可兼容旧版协议 服务端为旧版本，客户端为新版本时，服务端无法识别，须使用旧版本访问 数据包格式uint32 packet_length byte padding_length byte[n1] payload; n1 = packet_length - padding_length - 1 byte[n2] random padding; n2 = padding_length byte[m] mac (Message Authentication Code - MAC); m = mac_lengthpacket_length 数据包的长度(以字节为单位)，不包括’mac’或’packet_length’字段本身。 padding_length 随机填充字节的长度 payload 有效载荷：数据包的游泳内容。默认压缩为无，已协商压缩，此字段将被压缩 random padding 随机填充：任意长度的填充，使得总长度是密码块大小或8的倍数，取其较大者。必须至少由四个字节的填充，最大填充量是255个字节 mac 消息认证码，默认为无，若一些上，此字段包含MAC字节 压缩可选压缩，已协商压缩，则使用协商算法压缩“有效载荷”。 压缩方法：zlib可选ZLIB(LZ77)压缩 加密加密算法和密钥将在密钥交换期间进行协商。当加密生效时，每个数据包的数据包长度，填充长度，有效载荷和填充字段必须用给定算法加密。 数据完整性数据完整性通过在每个数据包中包含从共享密钥，数据包序列号和数据包内容计算出的MAC来加以保护。 消息认证算法和密钥在密钥交换期间进行协商，根据协商算法，计算方式为： mac = MAC（key，sequence_number || unencrypted_packet）unencrypted_packet是没有’mac’的整个分组 sequence_number是一个隐含的包序列号，表示为unit32格式 密钥交换采用Diffie-Hellman方法。密钥交换（kex）始于每边发送支持算法的名称列表 产生两个制：一个共享密钥K和一个交换散列H。加密和认证密钥来自于这两个值 流程 客户端和服务器端想对方发送SSH版本识别字符串 收到版本字符串后，双方通过质地的那个格式二进制包进行通信 在传输完版本字符串后，客户端和服务端开始进行密钥交换(key exchange，简称kex)。Kex用来让客户端和服务器生成本次通信的密钥和序列号。在kex的最后一步，服务器给客户端发送他的公钥，客户端查询本地的known_hosts查找志告公钥验证服务器身份。在kex之后，客户端进行SSH-AUTH，请求服务器验证自己的身份。 SSH-AUTH功能SSH认证协议提供了客户端认证功能，向服务器发起请求，验证客户端的合法性。 认证方法 password 密码验证 public key 无密码公钥验证 hostbased 基于主机的身份验证 规范身份验证请求消息格式： byte SSH_MSG_USERAUTH_REQUEST string user name(UTF-8) string service name(ASCII) string method name(ASCII) .... method specific fields如果用户名和服务名称发生改变，则断开连接 定义的方法名(method name)： &quot;publickey&quot; REQUIRED &quot;password&quot; OPTIONAL &quot;hostbased&quot; OPTIONAL &quot;none&quot; NOT RECOMMENDED认证协议消息号码一般的认证信息代码： SSH_MSG_USERAUTH_REQUEST 50 SSH_MSG_USERAUTH_FAILURE 51 SSH_MSG_USERAUTH_SUCCESS 52 SSH_MSG_USERAUTH_BANNER 53此外还有一些为方法特定的消息保留的消息编号(60到79) 认证方法1.公钥认证方法：publickey a. 客户端创建自己的密钥对，将公钥提交到需要访问的服务器上。 b. 客户端向服务器发起请求，请求用私钥签名进行认证。请求报文： byte SSH_MSG_USERAUTH_REQUEST string user name string service name string &quot;publickey&quot; boolean TRUE string public key algorithm name string public key to be used for authentication string signature其中签名项的内容为： string session identifier byte SSH_MSG_USERAUTH_REQUEST string user name string service name string &quot;publickey&quot; boolean TRUE string public key algorithm name string public key to be used for authenticationc. 服务器收到请求后，在公钥目录中查找对应用户，如果存在，则产生一个随机字符串，用公钥加密后发送给用户。 d. 用户收到字符串后，用自己的私钥进行解密，将解密后的字符串发送给服务器。 e. 服务器接收到字符串后与之前生成的随机字符串进行对比，如果一致，则允许用户登陆。 2.密码验证方法：password 客户端向服务器发起请求，发送包含自己用户名和对应密码的数据包，格式为： byte SSH_MSG_USERAUTH_REQUEST string user name string service name string &quot;password&quot; boolean FALSE string plaintext password(UTF-8)数据包由传输层进行加密 3.基于主机的身份验证:hostbased 通过来源主机和用户名进行身份验证，客户端发送消息请求身份认证，格式为： byte SSH_MSG_USERAUTH_REQUEST string user name string service name string &quot;hostbased&quot; string public key algorithm for host key string public host key and certificates for client host string client host name expressed as the FQDN(ASCII) string user name on the client host(UTF-8) string signature签名的值为： string session identifier byte SSH_MSG_USERAUTH_REQUEST string user name string service name string &quot;hostbased&quot; string public key algorithm for host key string public host key and certificates for client host string client host name expressed as the FQDN(ASCII) string user name on the client host(UTF-8)SSH-CONN功能提供交互式登陆会话，远程执行命令，转发TCP/IP连接和转发X11连接。 channel机制所有终端会话，转发连接等都是通过建立channel来通信的。任何一方都可以打开一个信道。多个信道被复用成一个单一的连接。 信道由末尾的数字进行标识。 信道是流量控制的。只有标为可用的窗口空间才可以发送数据。 打开信道任何一端都可以开启一个新的信道，并分配一个本地信道号。发送请求,包含本地信道号和初始窗口大小。请求格式： byte SSH_MSG_CHANNEL_OPEN string channel type(ASCII) uint32 sender channel uint32 initial window size uint32 maximum packet size .... channel type specific data follows远端回复是否可以打开信道： 打开信道 SSH_MSG_CHANNEL_OPEN_CONFIRMATION： byte SSH_MSG_CHANNEL_OPEN_CONFIRMATION uint32 recipient channel uint32 sender channel uint32 initial window size uint32 maximum packet size .... channel type specific data follows打开失败 SSH_MSG_CHANNEL_OPEN_FAILURE： byte SSH_MSG_CHANNEL_OPEN_FAILURE uint32 recipient channel uint32 reason code string description(UTF-8) string language tag原因代码(reason code)显示打开失败的原因 数据传输在打开新的信道时窗口大小已经规定，可以通过以下消息进行调整： byte SSH_MSG_CHANNEL_WINDOW_ADJUST uint32 recipient channel uint32 bytes to add窗口大小指定对方可以发送多少个字节。 数据传输的消息格式： byte SSH_MSG_CHANNEL_DATA uint32 recipient channel string data关闭信道当一方不再发送更多数据到一个信道时，应该发送SSH_MSG_CHANNEL_EOF，格式为： byte SSH_MSG_CHANNEL_EOF uint32 recipient channel当任何一方希望终止信道时，发送SSH_MSG_CHANNEL_CLOSE。收到此消息后，另一方必须回复一个SSH_MSG_CHANNEL_CLOSE。则该信道被视为已关闭。 特定信道请求许多信道类型值具有特定信道类型的扩展名。特定信道的请求格式为： byte SSH_MSG_CHANNEL_REQUEST uint32 recipient channel string request type(ASCII) boolean want reply .... type-specific data follows交互会话会话是程序的远程执行，该程序可以是shell，应用程序，系统命令或者某些内置子系统。会涉及到虚拟终端，X11转发。可以同时激活多个会话。 开始会话通过发送以下消息开始会话： byte SSH_MSG_CHANNEL_OPEN string &quot;session&quot; uint32 sender channel uint32 initial window size uint32 maximum packet size请求一个伪终端通过发送以下消息请求一个伪终端： byte SSH_MSG_CHANNEL_REQUEST uint32 recipient channel string &quot;pty-req&quot; boolean want_reply string TERM environment variable value uint32 terminal width, characters uint32 terminal height, rows uint32 terminal width, pixels uint32 terminal height, pixels string encoded terminal modesX11转发请求X11转发通过发送SSH_MSG_CHANNEL_REQUEST消息请求X11转发： byte SSH_MSG_CHANNEL_REQUEST uint32 recipient channel string &quot;x11-req&quot; boolean want reply boolean single connection string x11 authentication protocol string x11 authentication cookie uint32 x11 screen numberX11信道X11信道以信道开启请求的形式开启，请求通过的结果是开启一个独立于会话的信道，关闭会话信道不会关闭X11转发信道。请求格式为: byte SSH_MSG_CHANNEL_OPEN string &quot;x11&quot; uint32 sender channel uint32 initial window size uint32 maximum packet size string originator address uint32 originator port接受到请求的一方应使用SSH_MSG_CHANNEL_OPEN_CONFIRMATION开启信道或者SSH_MSG_CHANNEL_OPEN_FAILURE开启信道失败进行响应。 环境变量传递环境变量可以传递给shell/command。请求格式为： byte SSH_MSG_CHANNEL_REQUEST uint32 recipient channel string &quot;env&quot; boolean want reply string variable name string variable value启动shell/command会话建立时，远程终端的一个程序开启。这个程序可以是shell，应用程序，或者独立于主机的子系统。 byte SSH_MSG_CHANNEL_REQUEST uint32 recipient channel string &quot;shell&quot; boolean want reply该消息请求开启一个用户默认的shell byte SSH_MSG_CHANNEL_REQUEST uint32 recipient channel string &quot;exec&quot; boolean want reply string command该消息请求服务器执行给定的命令。’command’字符串可能包含一个路径。 byte SSH_MSG_CHANNEL_REQUEST uint32 recipient channel string &quot;subsystem&quot; boolean want reply string subsystem name该消息请求开启一个预定义的子系统。 会话数据传输会话的数据传输使用SSH_MSG_CHANNEL\DATA和SSH_MSG_CHANNEL_EXTENDED_DATA包和窗口机制。SSH_MSG_CHANNEL_EXTENDED_DATA已被定义为stderr数据。 其他控制消息 窗口尺寸更改消息 本地流量控制 信号 返回退出状态在另一端的命令终止时，会返回命令的退出状态。收到消息后，通过SSH_MSG_CHANNEL_CLOSE关闭信道。消息格式如下: byte SSH_MSG_CHANNEL_REQUEST uint32 recipient channel string &quot;exit-signal&quot; boolean FALSE string signal name (without the &quot;SIG&quot; prefix) boolean core dumped string error message(UTF-8) string language tagTCP/IP端口转发请求端口转发请求消息格式： byte SSH_MSG_GLOBAL_REQUEST string &quot;tcpip-forward&quot; boolean want reply string address to bind uint32 port number to bindTCP/IP转发信道当连接达到远程转发的端口被请求时，打开一个信道将端口转发给另一个端口侧。请求消息格式： byte SSH_MSG_CHANNEL_OPEN string &quot;forwarded-tcpip&quot; uint32 sender channel uint32 initial window size uint32 maximum packet size string address that was connected uint32 port that was connected string originator IP address uint32 originator port工作过程 版本号协商阶段，通信双方确定使用的协议版本 密钥和算法协商阶段，通信双方协商出最终使用的算法 认证阶段，SSH客户端向服务器端发起认证请求，服务器端对客户端进行认证 会话请求阶段，认证通过后，客户端向服务器端发送会话请求 交互会话阶段，会话请求通过后，服务器端和客户端进行交互会话]]></content>
      <categories>
        <category>协议</category>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tls]]></title>
    <url>%2F2019%2F06%2F18%2Ftls%2F</url>
    <content type="text"><![CDATA[SSL/TLS协议一、 概述关于SSL/TLS的历史和作用此处按下不表，可以检索相关文章进行了解。在建目录的时候，我还认证考虑了一下应该将SSL/TLS归类到几层协议中，经过思考和查找资料，我决定放弃，SSL/TLS协议基本上可以分为握手协议，和传输协议两部分，介于TCP和HTTP协议之间，可能并不太适用于与OSI模型进行匹配。 终于忙完了期末的若干事情，回来把这篇只开了头的文章写完。]]></content>
      <categories>
        <category>协议</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-charset]]></title>
    <url>%2F2019%2F06%2F17%2Fmysql-charset%2F</url>
    <content type="text"><![CDATA[数据库系列 1—MySQL数据库协议之字符集与排序开篇碎碎念​ 因为日常工作与数据库打交道，先准备写点简单的自己关于数据库的认识。今天刚好在看有关字符集协商的问题，简单的开篇讲一下MySQL中的字符集设定。 ​ MySQL数据库的设置与其协议都是简洁且自由度高的，这两种特性综合起来就导致了在使用MySQL数据库中会遇到一些由于灵活的配置导致的坑。 ​ 可能很多人都遇到过一个问题，就是在使用MySQL数据库时，会发先一些中文字符或者表情产生了乱码。或者使用了较新的客户端去连接服务器的时候，产生了类似于「ERROR 1115 (42000): Unknown character set: ‘utf8mb4’」这样连接失败的错误。 MySQL中的字符集character sets​ MySQL中的字符集由两部分构成，一是字符的编码方式(character sets)，二是编码的排序方式(collation)。看字面意思，编码方式就是单个字符的编码，排序方式就是比较字符之间顺序的规则。网上搜索相关的内容大多重复讲了这一点。 ​ 要搞清楚字符集，首先要弄明白字符集在什么时候需要。字符集是我们可见的字符在计算机中存储的一种方式，每个字符根据规则按照一定长度存储为十六进制（二进制）的值，而这个值如何解释则决定了它在打印时产生的字符。 ​ 首先要明确一个分类，字符集在数据库中有两大类的使用（我个人的理解，如有纰漏请指正）。我感觉网上现有的解释都混淆了这两类使用，导致不容易理解。 存储使用 传输使用 ​ 存储使用，就是在数据库服务端，对数据进行存储时使用的编码格式。在MySQL数据库中的表现为server, database, table, column四个层次的字符集设置，可以很详细地设定字符集。这个一般是在设计数据库时定义的，和我们要存储的数据的类型有关，通常也要同时确认其排序规则，关于排序规则后问再讲。 ​ 传输使用，发生在客户端（官方客户端或者我们自己的程序或者代理软件等等）和数据库服务器进行交互时。客户端和服务器交互，必然要进行通信，不论上层的封装是基于tcp/ip，还是pipe转发，本地套接字，其应用层的数据库协议都是相同的。服务端从库中取出数据，按照存储的字符集设定解释，然后再按照某种编码方式传输给客户端，客户端按照这种编码方式解释数据流；反之亦然。 ​ 如果我们自己来设计，服务器、客户端、传输协议中的编码方式最好是统一的，这样能够用最少的解释和编码过程。MySQL数据库的做法是让客户端声明一种编码方式，然后服务器与客户端的通信都使用同一种编码方式。在MySQL协议的握手过程中，服务端先发送第一个包，客户端在返回包时声明了自己要用的字符集以及排序方式。（字符集对排序方式是一对多的关系，因此也可以理解为只需要传输特定的排序方式）这个排序方式以一个字节的十六进制值表示。服务端收到这个字符集/排序方式后，查看自己是否支持，如果支持，则采用该方式进行编码解码，进行通行。如果不支持，则产生回退过程，服务器将自己支持的字符集发送给客户端，进行协商，客户端选择一种进行支持，或者双方无法达成一致，断开连接。可以说，在通信过程中，字符集的选择主要取决于客户端的声明。这一个字符集最后的表现形式为三项设定：character_set_client, character_set_results和character_set_connection。可以使用以下语句进行查询。 1SHOW SESSION VARIABLES LIKE 'character\_set\_%'; 可以看到这三项的值是统一的。据我现在的调研，各种客户端基本都不支持设置默认字符集，不同的客户端版本自己会声明一种字符集，5.5之前多数为latin1，5.7以后基本上都是utf8mb4，所以坑多为5.5.-5.7之间，可能存在声明utf8的字符集。一些比较奇怪的声明是客户端将这一标志位声明为0xff即255，但并没有对应的字符集，我猜测这可能是声称自己自持现有的所有字符集。可能是看到的文档版本不太对，最新的8.0.16文档中0xff(255)即是utf8mb4的标志。 ​ 客户端的配置项不提供指定字符集的方式，我们可以直接修改服务器中的三项设定 123SET character_set_client = charset_name;SET character_set_results = charset_name;SET character_set_connection = charset_name; 一般来说使用匹配版本的客户端和服务器，能够避免大量问题，如果要自己指定通信时的字符集，推荐5.1之前都使用latin1（5.5之前不止此utf8mb4编码），5.5以后都可以使用utf8mb4编码。注意：ucs2，utf16，utf32是不被支持的。 ​ 而关于之前容易产生的两种错误，第一个乱码的情况，一般是因为字符集不统一导致解码错误。在MySQL中，多数表现为按照utf8格式进行编码时产生的。因为历史遗留问题，MySQL中的一个坑是其utf8编码并不是我们通常认知中的utf8编码，这是一种最大长度为3字节的编码，因此当字符的长度是4字节时，解析就会出现错误，导致乱码的出现。MySQL官方也终于在MySQL5.5版本开始支持了4字节uft8，即utf8mb4字符集。第二个错误是使用了较高的（默认版本为5.7+）客户端连接较老的服务器（5.1），导致后续客户端申请更换字符集时遭到了拒绝。 1SET NAMES 'utf8mb4'; collations​ 排序方式是比较单个字符顺序的规则定义，比如忽视大小写，则A与a的排序是等同的；而b则应该排在a之后。每个字符编码方式都对应一种默认的排序方式。 尾记​ 第一次写文章，思路不够清晰，可能存在问题的地方也比较多，希望接下来能够清晰地做一个数据库专题，尤其是关于数据库协议相关的内容。 引用 https://dev.mysql.com/doc/refman/5.5/en/charset-connection.html]]></content>
      <categories>
        <category>database</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开篇]]></title>
    <url>%2F2019%2F06%2F13%2Findex%2F</url>
    <content type="text"><![CDATA[经过使用Jekyll搭建，再转向hexo，用next主题建起了博客；期间也入了OS X的坑。填了一些坑，走了一些歪路，总算是建起来了，也算是步入正轨。 博客中主要写一些技术分享的文章，看心情可能也会有日常记录。主要关注数据库技术，网络相关技术，各种协议以及关于服务器部署的相关技术。环境主要基于Linux/OS X，语言主要是C/go（未来希望能够熟悉C++，其他语言视需求扩展）。]]></content>
  </entry>
</search>
